<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo/guoba.png"><link rel="icon" href="/img/logo/guoba.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#A90113"><meta name="author" content="流星胖胖（MeteorAndy）"><meta name="keywords" content=""><meta name="description" content="数据结构笔记 指针（补充基础） 123456789101112131415161718192021&#x2F;&#x2F; 指针与双重指针#include &lt;stdio.h&gt;int main() {	printf(&quot;Hello world!\n&quot;);	int a &#x3D; 10;	int* ptr;&#x2F;&#x2F;这是一个指向整数的指针	ptr &#x3D; &amp;a;&#x2F;&#x2F;ptr本身是一个地址	int** dptr;&#x2F;&#x2F;这是经过"><meta property="og:type" content="article"><meta property="og:title" content="数据结构笔记"><meta property="og:url" content="https://meteorandy.netlify.app/posts/928debf2/index.html"><meta property="og:site_name" content="流星胖胖的小角落"><meta property="og:description" content="数据结构笔记 指针（补充基础） 123456789101112131415161718192021&#x2F;&#x2F; 指针与双重指针#include &lt;stdio.h&gt;int main() {	printf(&quot;Hello world!\n&quot;);	int a &#x3D; 10;	int* ptr;&#x2F;&#x2F;这是一个指向整数的指针	ptr &#x3D; &amp;a;&#x2F;&#x2F;ptr本身是一个地址	int** dptr;&#x2F;&#x2F;这是经过"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-02-20T01:51:15.000Z"><meta property="article:modified_time" content="2023-11-26T08:22:14.083Z"><meta property="article:author" content="流星胖胖（MeteorAndy）"><meta property="article:tag" content="学习"><meta property="article:tag" content="考研"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary_large_image"><title>数据结构笔记 - 流星胖胖的小角落</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"meteorandy.netlify.app",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!0,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#A90113",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"DpHUGCpJskfsvul9py9gnP22-9Nh9j0Va",app_key:"lIWlKO4kQ2PL8vpNLiY2uFNy",server_url:"https://dphugcpj.lc-cn-e1-shared.com",path:"window.location.pathname",ignore_local:!0},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>流星胖胖的小角落</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/workshop.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="数据结构笔记"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-20 09:51" pubdate>2023年2月20日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 90 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">数据结构笔记</h1><div class="markdown-body"><h1 id="数据结构笔记">数据结构笔记</h1><h2 id="指针补充基础">指针（补充基础）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指针与双重指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello world!\n"</span>);<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span>* ptr;<span class="hljs-comment">//这是一个指向整数的指针</span><br>	ptr = &amp;a;<span class="hljs-comment">//ptr本身是一个地址</span><br>	<span class="hljs-type">int</span>** dptr;<span class="hljs-comment">//这是经过两次才指向整数的指针</span><br>	dptr = &amp;ptr;<span class="hljs-comment">//ptr的货架号是2024</span><br>	<span class="hljs-comment">//dptr=2024</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, a);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x\n"</span>, &amp;a);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x\n"</span>, ptr);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *ptr);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x\n"</span>, &amp;ptr);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x\n"</span>, dptr);<span class="hljs-comment">//打印就是2024</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, **dptr);<span class="hljs-comment">//2024货架号上的包裹1024</span><br>	<span class="hljs-comment">//从1024货架号找包裹，也就是10</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="指针与双重指针的区别">指针与双重指针的区别</h3><p>指针相当于是一个快递的取件码，告诉你这个包裹存放在那个位置。</p><p>双重指针相当于是一个存放快递取件码的容器，告诉你这个快递取件码的位置，同时你也可以再通过这个快递取件码去访问到包裹所在的位置。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 传值</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><span class="hljs-comment">//int a=10，是set函数的a</span><br>{<br>	a = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Set的a=%d\n"</span>, a);<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"调用之前的a=%d\n"</span>, a);<br>	<span class="hljs-built_in">set</span>(a);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"调用之后的a=%d\n"</span>, a);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 传引用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span><span class="hljs-comment">//int a=10，是set函数的a</span><br>{<span class="hljs-comment">//int *a;a=1024</span><br>	*a = <span class="hljs-number">0</span>;<span class="hljs-comment">//对1024货架上的包裹重新换一个</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Set的a=%d\n"</span>, *a);<span class="hljs-comment">//打印货架内容</span><br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"调用之前的a=%d\n"</span>, a);<br>	<span class="hljs-built_in">set</span>(&amp;a);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"调用之后的a=%d\n"</span>, a);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="传值和传引用的区别">传值和传引用的区别：</h3><p>传值相当于复制一份，会在内存中产生一个新的变量，相当于 A 复制一瓶可乐给 B 喝，B 喝完了可乐并不影响 A 的可乐。</p><p>传引用相当于 A、B 两个人一起喝同一瓶可乐，当 B 喝完了可乐，A 也会喝不到可乐。</p><h3 id="传引用的示例">传引用的示例</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 写出一个函数，实现a和b加减乘除</span><br><span class="hljs-comment">// 并返回这四个值</span><br><span class="hljs-comment">// 通过传引用的方式将main函数中的sum、sub、mul、div的地址传入到“加减乘除”函数，使“加减乘除”函数可以直接在函数中调用并修改main函数中的sum、sub、mul、div。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jjcc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; sum, <span class="hljs-type">int</span>&amp; sub, <span class="hljs-type">int</span>&amp; mul, <span class="hljs-type">int</span>&amp; div)</span> </span>{<br>	sum = a + b;<br>	sub = a - b;<br>	mul = a * b;<br>	div = a / b;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>	<span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, sub = <span class="hljs-number">0</span>, mul = <span class="hljs-number">0</span>, div = <span class="hljs-number">0</span>;<br>	cout &lt;&lt; <span class="hljs-string">"sum="</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; <span class="hljs-string">"sub="</span> &lt;&lt; sub &lt;&lt; endl &lt;&lt; <span class="hljs-string">"mul="</span> &lt;&lt; mul &lt;&lt; endl &lt;&lt; <span class="hljs-string">"div="</span> &lt;&lt; div &lt;&lt; endl;<br>	<span class="hljs-built_in">jjcc</span>(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, sum, sub, mul, div);<br>	cout &lt;&lt; <span class="hljs-string">"sum="</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; <span class="hljs-string">"sub="</span> &lt;&lt; sub &lt;&lt; endl &lt;&lt; <span class="hljs-string">"mul="</span> &lt;&lt; mul &lt;&lt; endl &lt;&lt; <span class="hljs-string">"div="</span> &lt;&lt; div &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="老师教案补充">老师教案补充</h3><div class="row"><embed src="./记住一句话，地址就是指针，指针就是地址。.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="顺序表">顺序表</h2><pre><code class="mermaid">graph LR
线性表--&gt;顺序表
线性表--&gt;链表
</code></pre><p>顺序表（Sequential List）是一种线性数据结构，<strong>它采用数组来实现，元素在内存中的存储是连续的，每个元素占用相同的内存空间，因此可以通过下标快速地访问任意位置的元素。</strong></p><p>顺序表可以实现随机访问，即可以在 O(1)时间复杂度内访问任意位置的元素，但是在插入和删除操作时，需要移动其他元素，因此时间复杂度为 O(n)。此外，如果顺序表已满，需要扩容，也会导致较大的时间开销。</p><p>顺序表适合于静态存储数据，即数据量固定不变的情况。如果需要频繁插入和删除元素，建议使用链表等动态数据结构。</p><h3 id="结构体类似于其他语言中的类">结构体（类似于其他语言中的类）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqList</span> {<br>	<span class="hljs-type">int</span> data[MAXSIZE];<br>	<span class="hljs-type">int</span> length;<br>};<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEX int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Male 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Female 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<br>	string name;<br>	<span class="hljs-type">int</span> age;<br>	<span class="hljs-type">float</span> height;<br>	SEX sex;<br>}Person;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>	<span class="hljs-comment">// 第一种写法（初始化）</span><br>	Person wbq = { <span class="hljs-string">"王宝强"</span>,<span class="hljs-number">30</span>,<span class="hljs-number">170</span>,<span class="hljs-number">1</span> };<br>	<span class="hljs-comment">// 第二种写法（最常见）</span><br>	<span class="hljs-comment">// wbq.age = 30;</span><br>	<span class="hljs-comment">// wbq.name = "王宝强";</span><br>	<span class="hljs-comment">// wbq.height = 170;</span><br>	<span class="hljs-comment">// 第三种写法（最常用） ym地址相当于身份证，*ym才是这个地址所指向的变量</span><br>	Person* ym = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>	<span class="hljs-comment">// (*ym).name = "杨幂"; (第三种中更少用的)</span><br>	ym-&gt;name = <span class="hljs-string">"杨幂"</span>; <span class="hljs-comment">// 第三中更常用的</span><br>	cout &lt;&lt; ym-&gt;name &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="静态分配">静态分配</h3><h4 id="chatgpt-代码">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>; <span class="hljs-comment">// 定义最大容量为100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<br>    <span class="hljs-type">int</span> data[MAX_SIZE]; <span class="hljs-comment">// 存放元素的数组</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 当前长度</span><br>} SqList;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    SqList list;<br>    list.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化长度为0</span><br><br>    <span class="hljs-comment">// 添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>        list.data[i] = i+<span class="hljs-number">1</span>;<br>        list.length++;<br>    }<br><br>    <span class="hljs-comment">// 遍历顺序表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {<br>        cout &lt;&lt; list.data[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>顺序表最简单的方法是使用一个定长数组 data[]存储数据，最大空间为 Maxsize，用 length 记录实际的元素个数，即顺序表的长度。这种用定长数组存储的方法称为静态分配。</p><h3 id="动态分配">动态分配</h3><p>在程序运行过程中，根据需要动态分配一段连续的空间(大小为 Maxsize)，用 elem 记录该空间的基地址（首地址)，用 length 记录实际的元素个数，即顺序表的长度。采用动态存储方法，在运算过程中，如果发生溢出，可以另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储空间的目的。</p><h3 id="动态分配构建顺序表的代码">动态分配构建顺序表的代码</h3><h4 id="老师代码">老师代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<br>    <span class="hljs-type">int</span>* elem; <span class="hljs-comment">// 基地址</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 有效长度</span><br>}SqList;<br><br><span class="hljs-comment">// 初始化线性表</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    L.elem = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[MAXSIZE];<br>    <span class="hljs-keyword">if</span> (!L.elem) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存储分配失败</span><br>    L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空表长度为0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 销毁线性表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    <span class="hljs-keyword">delete</span>[] L.elem;<br>    L.elem = <span class="hljs-literal">nullptr</span>;<br>    L.length = <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 清空线性表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    L.length = <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    <span class="hljs-keyword">return</span> L.length == <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 获取线性表的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    <span class="hljs-keyword">return</span> L.length;<br>}<br><br><span class="hljs-comment">// 获取线性表中第i个元素的值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>&amp; e)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// i值不合法</span><br>    e = L.elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 查找线性表中第一个值等于e的元素的位序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> e)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) {<br>        <span class="hljs-keyword">if</span> (L.elem[i] == e) {<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 在线性表第i个位置插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// i值不合法</span><br>    <span class="hljs-keyword">if</span> (L.length &gt;= MAXSIZE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线性表已满</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length; j &gt;= i; j--) {<br>        L.elem[j] = L.elem[j - <span class="hljs-number">1</span>];<br>    }<br>    L.elem[i - <span class="hljs-number">1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 删除线性表中第i个元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>&amp; e)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// i值不合法</span><br>    e = L.elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length; j++) {<br>        L.elem[j - <span class="hljs-number">1</span>] = L.elem[j];<br>    }<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 打印线性表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(SqList&amp; L)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) {<br>        cout &lt;&lt; L.elem[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    SqList L;<br>    <span class="hljs-built_in">InitList</span>(L);<br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">PrintList</span>(L);<br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-built_in">ListDelete</span>(L, <span class="hljs-number">2</span>, e);<br>    cout &lt;&lt; <span class="hljs-string">"Deleted element: "</span> &lt;&lt; e &lt;&lt; endl;<br>    <span class="hljs-built_in">PrintList</span>(L);<br>    <span class="hljs-built_in">DestroyList</span>(L);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-1">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<br>    <span class="hljs-type">int</span> *data; <span class="hljs-comment">// 存储数据的数组</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 最大容量</span><br>} SqList; <span class="hljs-comment">// 定义线性表结构体</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(SqList &amp;list, <span class="hljs-type">int</span> size)</span> </span>{ <span class="hljs-comment">// 初始化线性表</span><br>    list.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 动态分配内存</span><br>    list.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始长度为0</span><br>    list.capacity = size; <span class="hljs-comment">// 最大容量为size</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(SqList &amp;list, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 向线性表中添加元素</span><br>    <span class="hljs-keyword">if</span> (list.length == list.capacity) { <span class="hljs-comment">// 如果线性表已满</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 添加失败</span><br>    }<br>    list.data[list.length++] = value; <span class="hljs-comment">// 向线性表中添加元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 添加成功</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(SqList &amp;list)</span> </span>{ <span class="hljs-comment">// 遍历线性表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) { <span class="hljs-comment">// 遍历线性表中的元素</span><br>        cout &lt;&lt; list.data[i] &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出元素</span><br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 换行</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(SqList &amp;list)</span> </span>{ <span class="hljs-comment">// 销毁线性表</span><br>    <span class="hljs-keyword">delete</span>[] list.data; <span class="hljs-comment">// 释放内存</span><br>    list.data = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 指针置空</span><br>    list.length = list.capacity = <span class="hljs-number">0</span>; <span class="hljs-comment">// 长度和容量置为0</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    SqList list; <span class="hljs-comment">// 定义线性表</span><br>    <span class="hljs-built_in">init</span>(list, MAX_SIZE); <span class="hljs-comment">// 初始化线性表</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_SIZE; i++) { <span class="hljs-comment">// 向线性表中添加元素</span><br>        <span class="hljs-built_in">add</span>(list, i);<br>    }<br><br>    <span class="hljs-built_in">traverse</span>(list); <span class="hljs-comment">// 遍历线性表</span><br><br>    <span class="hljs-built_in">destroy</span>(list); <span class="hljs-comment">// 销毁线性表</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="链表">链表</h2><p>链表（Linked List）是一种常见的线性数据结构，<strong>它由一系列节点组成，每个节点包含两个部分：数据域和指针域。数据域存储节点的值，指针域存储下一个节点的地址。</strong></p><p>链表中的节点不必在内存中连续地存储，它们可以分散在内存中的任何位置。每个节点只知道下一个节点的位置，因此链表的访问通常需要遍历整个链表。</p><p>链表分为单向链表和双向链表两种类型。单向链表每个节点只有一个指针域，指向下一个节点，而双向链表每个节点有两个指针域，一个指向前一个节点，一个指向后一个节点。双向链表相对于单向链表，可以实现双向遍历、删除和插入操作。</p><p>链表适合用于动态存储数据，即数据量可能变化的情况。与数组相比，链表的插入和删除操作更为高效，但是随机访问的效率较低。</p><p>在程序设计中，链表被广泛应用于实现栈、队列、哈希表等数据结构。掌握链表的基本原理和操作，对于编写高效的程序具有很重要的作用。</p><h3 id="链表代码">链表代码</h3><h4 id="老师代码-1">老师代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 链表节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-type">int</span> data;             <span class="hljs-comment">// 数据</span><br>    ListNode *next;       <span class="hljs-comment">// 指向下一个节点的指针</span><br>} ListNode;<br><br><span class="hljs-comment">// 初始化链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(ListNode *&amp;head)</span> </span>{<br>    head = <span class="hljs-literal">nullptr</span>;<br>}<br><br><span class="hljs-comment">// 在链表头部插入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsertHead</span><span class="hljs-params">(ListNode *&amp;head, <span class="hljs-type">int</span> data)</span> </span>{<br>    <span class="hljs-keyword">auto</span> *newNode = <span class="hljs-keyword">new</span> ListNode;<br>    newNode-&gt;data = data;<br>    newNode-&gt;next = head;<br>    head = newNode;<br>}<br><br><span class="hljs-comment">// 在链表尾部插入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsertTail</span><span class="hljs-params">(ListNode *&amp;head, <span class="hljs-type">int</span> data)</span> </span>{<br>    <span class="hljs-keyword">auto</span> *newNode = <span class="hljs-keyword">new</span> ListNode;<br>    newNode-&gt;data = data;<br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {<br>        head = newNode;<br>    } <span class="hljs-keyword">else</span> {<br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            p = p-&gt;next;<br>        }<br>        p-&gt;next = newNode;<br>    }<br>}<br><br><span class="hljs-comment">// 删除链表中的某个元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(ListNode *&amp;head, <span class="hljs-type">int</span> data)</span> </span>{<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (head-&gt;data == data) {<br>        ListNode *p = head;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    ListNode *p = head-&gt;next;<br>    ListNode *prev = head;<br><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != data) {<br>        prev = p;<br>        p = p-&gt;next;<br>    }<br><br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data == data) {<br>        prev-&gt;next = p-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 查找链表中是否存在某个元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListFind</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> data)</span> </span>{<br>    ListNode *p = head;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) {<br>        <span class="hljs-keyword">if</span> (p-&gt;data == data) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        p = p-&gt;next;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><span class="hljs-comment">// 打印链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListPrint</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>    ListNode *p = head;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) {<br>        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;<br>        p = p-&gt;next;<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    ListNode *head;<br>    <span class="hljs-built_in">InitList</span>(head);<br><br>    <span class="hljs-built_in">ListInsertHead</span>(head, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">ListInsertHead</span>(head, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">ListInsertHead</span>(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">ListPrint</span>(head);   <span class="hljs-comment">// 1 2 3</span><br><br>    <span class="hljs-built_in">ListInsertTail</span>(head, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">ListInsertTail</span>(head, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">ListInsertTail</span>(head, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">ListPrint</span>(head);   <span class="hljs-comment">// 1 2 3 4 5 6</span><br><br>    <span class="hljs-built_in">ListDelete</span>(head, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">ListPrint</span>(head);   <span class="hljs-comment">// 1 2 4 5 6</span><br><br>    <span class="hljs-built_in">ListDelete</span>(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">ListDelete</span>(head, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">ListPrint</span>(head);   <span class="hljs-comment">// 2 4 5</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ListFind</span>(head, <span class="hljs-number">2</span>)) {<br>        cout &lt;&lt; <span class="hljs-string">"2 is in the list."</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt; <span class="hljs-string">"2 is not in the list."</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ListFind</span>(head, <span class="hljs-number">3</span>)) {<br>        cout &lt;&lt; <span class="hljs-string">"3 is in the list."</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt; <span class="hljs-string">"3 is not in the list."</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-2">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> {<br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* next; <span class="hljs-comment">// 指向下一个节点的指针</span><br>} node, *Node;<br><br><span class="hljs-function">Node <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 创建一个新节点</span><br>    Node newNode = <span class="hljs-keyword">new</span> node; <span class="hljs-comment">// 分配内存</span><br>    newNode-&gt;data = value; <span class="hljs-comment">// 赋值</span><br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 初始化指针</span><br>    <span class="hljs-keyword">return</span> newNode; <span class="hljs-comment">// 返回新节点</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(Node&amp; head, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 在链表头插入节点</span><br>    Node newNode = <span class="hljs-built_in">createNode</span>(value); <span class="hljs-comment">// 创建新节点</span><br>    newNode-&gt;next = head; <span class="hljs-comment">// 新节点指向原头节点</span><br>    head = newNode; <span class="hljs-comment">// 更新头节点</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtTail</span><span class="hljs-params">(Node&amp; head, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 在链表尾插入节点</span><br>    Node newNode = <span class="hljs-built_in">createNode</span>(value); <span class="hljs-comment">// 创建新节点</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果链表为空</span><br>        head = newNode; <span class="hljs-comment">// 新节点为头节点</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果链表不为空</span><br>        Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>        <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 找到最后一个节点</span><br>            temp = temp-&gt;next;<br>        }<br>        temp-&gt;next = newNode; <span class="hljs-comment">// 最后一个节点指向新节点</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtMid</span><span class="hljs-params">(Node&amp; head, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>{ <span class="hljs-comment">// 在链表中间插入节点</span><br>    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 位置无效</span><br>        cout &lt;&lt; <span class="hljs-string">"Invalid position"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 在头部插入节点</span><br>        <span class="hljs-built_in">insertAtHead</span>(head, value);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    Node newNode = <span class="hljs-built_in">createNode</span>(value); <span class="hljs-comment">// 创建新节点</span><br>    Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; position - <span class="hljs-number">1</span> &amp;&amp; temp != <span class="hljs-literal">nullptr</span>; i++) { <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>        temp = temp-&gt;next;<br>    }<br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 位置无效</span><br>        cout &lt;&lt; <span class="hljs-string">"Invalid position"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    newNode-&gt;next = temp-&gt;next; <span class="hljs-comment">// 新节点指向原位置的节点</span><br>    temp-&gt;next = newNode; <span class="hljs-comment">// 前一个节点指向新节点</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtHead</span><span class="hljs-params">(Node&amp; head)</span> </span>{ <span class="hljs-comment">// 删除头节点</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果链表为空</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    Node temp = head; <span class="hljs-comment">// 保存头节点</span><br>    head = head-&gt;next; <span class="hljs-comment">// 更新头节点</span><br>    <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">// 释放内存</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtTail</span><span class="hljs-params">(Node&amp; head)</span> </span>{ <span class="hljs-comment">// 删除尾节点</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果链表为空</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果链表只有一个节点</span><br>        <span class="hljs-keyword">delete</span> head; <span class="hljs-comment">// 释放内存</span><br>        head = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 头节点为空</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">while</span> (temp-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 找到倒数第二个节点</span><br>        temp = temp-&gt;next;<br>    }<br>    <span class="hljs-keyword">delete</span> temp-&gt;next; <span class="hljs-comment">// 释放内存</span><br>    temp-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 倒数第二个节点指向空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtMid</span><span class="hljs-params">(Node&amp; head, <span class="hljs-type">int</span> position)</span> </span>{ <span class="hljs-comment">// 删除中间节点</span><br>    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 位置无效</span><br>        cout &lt;&lt; <span class="hljs-string">"Invalid position"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 删除头节点</span><br>        <span class="hljs-built_in">deleteAtHead</span>(head);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; position - <span class="hljs-number">1</span> &amp;&amp; temp != <span class="hljs-literal">nullptr</span>; i++) { <span class="hljs-comment">// 找到要删除的节点的前一个节点</span><br>        temp = temp-&gt;next;<br>    }<br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">nullptr</span> || temp-&gt;next == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 位置无效</span><br>        cout &lt;&lt; <span class="hljs-string">"Invalid position"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    Node toDelete = temp-&gt;next; <span class="hljs-comment">// 要删除的节点</span><br>    temp-&gt;next = toDelete-&gt;next; <span class="hljs-comment">// 前一个节点指向要删除节点的下一个节点</span><br>    <span class="hljs-keyword">delete</span> toDelete; <span class="hljs-comment">// 释放内存</span><br>}<br><br><span class="hljs-function">Node <span class="hljs-title">searchNode</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 查找节点</span><br>    Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span> &amp;&amp; temp-&gt;data != value) { <span class="hljs-comment">// 找到值为value的节点</span><br>        temp = temp-&gt;next;<br>    }<br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// 返回节点</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverseList</span><span class="hljs-params">(Node head)</span> </span>{ <span class="hljs-comment">// 遍历链表</span><br>    Node temp = head; <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 遍历整个链表</span><br>        cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出节点数据</span><br>        temp = temp-&gt;next; <span class="hljs-comment">// 移动到下一个节点</span><br>    }<br>    cout &lt;&lt; endl; <span class="hljs-comment">// 换行</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Node head = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 头节点为空</span><br>    <span class="hljs-built_in">insertAtHead</span>(head, <span class="hljs-number">1</span>); <span class="hljs-comment">// 在头部插入节点</span><br>    <span class="hljs-built_in">insertAtHead</span>(head, <span class="hljs-number">2</span>); <span class="hljs-comment">// 在头部插入节点</span><br>    <span class="hljs-built_in">insertAtTail</span>(head, <span class="hljs-number">3</span>); <span class="hljs-comment">// 在尾部插入节点</span><br>    <span class="hljs-built_in">insertAtMid</span>(head, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 在中间插入节点</span><br>    <span class="hljs-built_in">traverseList</span>(head); <span class="hljs-comment">// 遍历链表</span><br>    <span class="hljs-built_in">deleteAtHead</span>(head); <span class="hljs-comment">// 删除头节点</span><br>    <span class="hljs-built_in">deleteAtTail</span>(head); <span class="hljs-comment">// 删除尾节点</span><br>    <span class="hljs-built_in">deleteAtMid</span>(head, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除中间节点</span><br>    <span class="hljs-built_in">traverseList</span>(head); <span class="hljs-comment">// 遍历链表</span><br>    Node node = <span class="hljs-built_in">searchNode</span>(head, <span class="hljs-number">3</span>); <span class="hljs-comment">// 查找节点</span><br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果找到了节点</span><br>        cout &lt;&lt; <span class="hljs-string">"Found node: "</span> &lt;&lt; node-&gt;data &lt;&lt; endl; <span class="hljs-comment">// 输出节点数据</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果没有找到节点</span><br>        cout &lt;&lt; <span class="hljs-string">"Node not found"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 程序结束</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="老师教案补充-1">老师教案补充</h3><div class="row"><embed src="./单链表教案.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="栈">栈</h2><p>栈是一种线性数据结构，它具有后进先出（LIFO）的特点。栈可以通过数组或链表实现。栈有两个基本操作：push 和 pop。push 操作将元素添加到栈的顶部，而 pop 操作将元素从栈的顶部删除。栈还有一个 peek 操作，它返回栈顶元素而不删除它。栈还可以用于实现递归算法、表达式求值、内存管理等。栈的应用非常广泛，是计算机科学中最基本的数据结构之一。</p><h3 id="基于数组实现的栈">基于数组实现的栈</h3><h4 id="老师代码-2">老师代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> size 3</span><br><span class="hljs-type">int</span> arr[size];<br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (top == size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//返回-1表示错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><span class="hljs-comment">//栈顶是栈中最高元素对应的索引</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>())<br>        <span class="hljs-keyword">return</span>;<br>    arr[++top] = value;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//返回-1表示错误</span><br>    <span class="hljs-keyword">return</span> arr[top--];<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//将10压入栈中</span><br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//将20压入栈中</span><br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<span class="hljs-comment">//将30压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出30，因为30最后被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出20，因为20在30之前被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出10，因为10在20之前被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出-1，因为栈已经为空，无法弹出元素</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-3">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> {<br>    <span class="hljs-type">int</span> data[MAXSIZE]; <span class="hljs-comment">// 栈的数据域</span><br>    <span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>} stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 初始化栈</span><br>    s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈顶指针初始化为-1</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(stack&amp; s, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入栈操作</span><br>    <span class="hljs-keyword">if</span> (s.top == MAXSIZE - <span class="hljs-number">1</span>) { <span class="hljs-comment">// 栈满</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接返回</span><br>    }<br>    s.data[++s.top] = value; <span class="hljs-comment">// 栈顶指针加1，将元素入栈</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 出栈操作</span><br>    <span class="hljs-keyword">if</span> (s.top == <span class="hljs-number">-1</span>) { <span class="hljs-comment">// 栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-type">int</span> value = s.data[s.top--]; <span class="hljs-comment">// 取出栈顶元素，栈顶指针减1</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回栈顶元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 取栈顶元素</span><br>    <span class="hljs-keyword">if</span> (s.top == <span class="hljs-number">-1</span>) { <span class="hljs-comment">// 栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> s.data[s.top]; <span class="hljs-comment">// 返回栈顶元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> s.top == <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈顶指针为-1，即为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否为满</span><br>    <span class="hljs-keyword">return</span> s.top == MAXSIZE - <span class="hljs-number">1</span>; <span class="hljs-comment">// 栈顶指针为MAXSIZE-1，即为满</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack s; <span class="hljs-comment">// 定义一个栈</span><br>    <span class="hljs-built_in">initStack</span>(s); <span class="hljs-comment">// 初始化栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入栈10</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">20</span>); <span class="hljs-comment">// 入栈20</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">30</span>); <span class="hljs-comment">// 入栈30</span><br>    cout &lt;&lt; <span class="hljs-built_in">top</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 输出栈顶元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 判断栈是否为空</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="基于链表实现的栈">基于链表实现的栈</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> {<br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">//定义一个整型数据</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next; <span class="hljs-comment">//定义一个指向结构体的指针</span><br>} Node; <span class="hljs-comment">//定义一个结构体</span><br><br>Node *head = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//定义一个指向结构体的指针</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">//定义一个函数，将一个整型数据压入栈中</span><br>    Node *newNode = <span class="hljs-keyword">new</span> Node; <span class="hljs-comment">//定义一个指向结构体的指针，指向一个新的结构体</span><br>    newNode-&gt;data = value; <span class="hljs-comment">//将新结构体的数据域赋值为value</span><br>    newNode-&gt;next = head; <span class="hljs-comment">//将新结构体的指针域指向head</span><br>    head = newNode; <span class="hljs-comment">//将head指向新结构体</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//定义一个函数，从栈中弹出一个整型数据</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">//如果head为空</span><br>        cout &lt;&lt; <span class="hljs-string">"栈为空"</span> &lt;&lt; endl; <span class="hljs-comment">//输出"栈为空"</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//返回-1</span><br>    }<br>    Node *temp = head; <span class="hljs-comment">//定义一个指向结构体的指针，指向head</span><br>    <span class="hljs-type">int</span> deletedValue = temp-&gt;data; <span class="hljs-comment">//将deletedValue赋值为temp的数据域</span><br>    head = head-&gt;next; <span class="hljs-comment">//将head指向下一个结构体</span><br>    <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">//删除temp指向的结构体</span><br>    <span class="hljs-keyword">return</span> deletedValue; <span class="hljs-comment">//返回deletedValue</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//主函数</span><br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//将10压入栈中</span><br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//将20压入栈中</span><br>    <span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<span class="hljs-comment">//将30压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出30，因为30最后被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出20，因为20在30之前被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出10，因为10在20之前被压入栈中</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>() &lt;&lt; endl;<span class="hljs-comment">//输出-1，因为栈已经为空，无法弹出元素</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-4">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> { <span class="hljs-comment">// 定义结构体node</span><br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* next; <span class="hljs-comment">// 指针域</span><br>} node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> { <span class="hljs-comment">// 定义结构体stack</span><br>    node* top; <span class="hljs-comment">// 栈顶指针</span><br>} stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 初始化栈</span><br>    s.top = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 栈顶指针置空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(stack&amp; s, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入栈操作</span><br>    node* newNode = <span class="hljs-keyword">new</span> node; <span class="hljs-comment">// 创建新节点</span><br>    newNode-&gt;data = value; <span class="hljs-comment">// 节点数据域赋值</span><br>    newNode-&gt;next = s.top; <span class="hljs-comment">// 新节点指向栈顶</span><br>    s.top = newNode; <span class="hljs-comment">// 栈顶指针指向新节点</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 出栈操作</span><br>    <span class="hljs-keyword">if</span> (s.top == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 栈为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Stack is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-type">int</span> value = s.top-&gt;data; <span class="hljs-comment">// 取出栈顶元素</span><br>    node* temp = s.top; <span class="hljs-comment">// 保存栈顶指针</span><br>    s.top = s.top-&gt;next; <span class="hljs-comment">// 栈顶指针指向下一个节点</span><br>    <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">// 释放原栈顶节点</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回栈顶元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 取栈顶元素</span><br>    <span class="hljs-keyword">if</span> (s.top == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 栈为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Stack is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> s.top-&gt;data; <span class="hljs-comment">// 返回栈顶元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> s.top == <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 栈顶指针为空则栈为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack s; <span class="hljs-comment">// 创建栈</span><br>    <span class="hljs-built_in">initStack</span>(s); <span class="hljs-comment">// 初始化栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">30</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">top</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 取栈顶元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 判断栈是否为空</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="老师教案补充-2">老师教案补充</h3><div class="row"><embed src="./栈的实现.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="队列">队列</h2><p>队列是一种线性数据结构，它只允许在一端进行插入操作，在另一端进行删除操作。队列的特点是先进先出，即先插入的元素先被删除。</p><h3 id="队列的操作">队列的操作</h3><p>队列的主要操作有两个：</p><ul><li>入队（enqueue）：在队列的末尾插入一个元素。</li><li>出队（dequeue）：删除队列的第一个元素。</li></ul><p>除此之外，队列还有一些其他的操作：</p><ul><li>队列的长度（length）：返回队列中元素的个数。</li><li>队列是否为空（is_empty）：如果队列中没有元素，返回 True，否则返回 False。</li><li>队列的第一个元素（first）：返回队列的第一个元素，但不删除它。</li><li>队列的最后一个元素（last）：返回队列的最后一个元素，但不删除它。</li></ul><h3 id="基于数组实现的队列">基于数组实现的队列</h3><h4 id="老师代码-3">老师代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> size 3</span><br><br><span class="hljs-type">int</span> arr[size];<br><span class="hljs-type">int</span> front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>    <span class="hljs-comment">// 如果队列已满，直接返回</span><br>    <span class="hljs-keyword">if</span> (rear == size) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-comment">// 将元素插入队尾</span><br>    arr[rear++] = value;<br>}<br><br><span class="hljs-comment">// 出队操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 如果队列为空，返回-1</span><br>    <span class="hljs-keyword">if</span> (front == rear &amp;&amp; front != <span class="hljs-number">0</span>) {<br>        <span class="hljs-comment">// 重置队列</span><br>        front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 如果队列为空，返回-1</span><br>    <span class="hljs-keyword">if</span> (front == rear)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 返回队首元素并将队首指针后移</span><br>    <span class="hljs-keyword">return</span> arr[front++];<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">// 出队操作</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">// 出队操作</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-5">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queue</span> {<br>    <span class="hljs-type">int</span>* data; <span class="hljs-comment">// 队列数据</span><br>    <span class="hljs-type">int</span> front; <span class="hljs-comment">// 队首指针</span><br>    <span class="hljs-type">int</span> rear; <span class="hljs-comment">// 队尾指针</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// 队列大小</span><br>} queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(queue&amp; q, <span class="hljs-type">int</span> size)</span> </span>{ <span class="hljs-comment">// 初始化队列</span><br>    q.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 动态分配内存</span><br>    q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队首队尾指针初始化为0</span><br>    q.size = size; <span class="hljs-comment">// 队列大小</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(queue&amp; q, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入队</span><br>    <span class="hljs-keyword">if</span> ((q.rear + <span class="hljs-number">1</span>) % q.size == q.front) { <span class="hljs-comment">// 判断队列是否已满</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is full"</span> &lt;&lt; endl; <span class="hljs-comment">// 队列已满</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    q.data[q.rear] = value; <span class="hljs-comment">// 入队操作</span><br>    q.rear = (q.rear + <span class="hljs-number">1</span>) % q.size; <span class="hljs-comment">// 队尾指针后移</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 出队</span><br>    <span class="hljs-keyword">if</span> (q.front == q.rear) { <span class="hljs-comment">// 判断队列是否为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 队列为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> value = q.data[q.front]; <span class="hljs-comment">// 出队操作</span><br>    q.front = (q.front + <span class="hljs-number">1</span>) % q.size; <span class="hljs-comment">// 队首指针后移</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回出队元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队首元素</span><br>    <span class="hljs-keyword">if</span> (q.front == q.rear) { <span class="hljs-comment">// 判断队列是否为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 队列为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> q.data[q.front]; <span class="hljs-comment">// 返回队首元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rear</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队尾元素</span><br>    <span class="hljs-keyword">if</span> (q.front == q.rear) { <span class="hljs-comment">// 判断队列是否为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 队列为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> index = (q.rear - <span class="hljs-number">1</span> + q.size) % q.size; <span class="hljs-comment">// 计算队尾元素下标</span><br>    <span class="hljs-keyword">return</span> q.data[index]; <span class="hljs-comment">// 返回队尾元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">return</span> q.front == q.rear;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-keyword">return</span> (q.rear + <span class="hljs-number">1</span>) % q.size == q.front;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue q;<br>    <span class="hljs-built_in">initQueue</span>(q, <span class="hljs-number">5</span>); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">20</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">30</span>); <span class="hljs-comment">// 入队</span><br>    cout &lt;&lt; <span class="hljs-built_in">front</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队首元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">rear</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队尾元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队</span><br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否为空</span><br>    cout &lt;&lt; <span class="hljs-built_in">isFull</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">40</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">50</span>); <span class="hljs-comment">// 入队</span><br>    cout &lt;&lt; <span class="hljs-built_in">isFull</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">60</span>); <span class="hljs-comment">// 入队</span><br>    cout &lt;&lt; <span class="hljs-built_in">isFull</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="基于链表实现的队列">基于链表实现的队列</h3><h4 id="老师代码-4">老师代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> {<br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next; <span class="hljs-comment">//指针域</span><br>} node, *Node;<br><br>Node front = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//队头指针</span><br>Node rear = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//队尾指针</span><br><br><span class="hljs-comment">//入队操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>    Node newNode = <span class="hljs-keyword">new</span> node; <span class="hljs-comment">//创建新节点</span><br>    newNode-&gt;data = value; <span class="hljs-comment">//新节点数据域赋值</span><br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//新节点指针域赋值</span><br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span> &amp;&amp; rear == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">//如果队列为空</span><br>        front = newNode; <span class="hljs-comment">//队头指针指向新节点</span><br>        rear = newNode; <span class="hljs-comment">//队尾指针指向新节点</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">//如果队列不为空</span><br>        rear-&gt;next = newNode; <span class="hljs-comment">//队尾指针指向新节点</span><br>        rear = newNode; <span class="hljs-comment">//队尾指针指向新节点</span><br>    }<br>}<br><br><span class="hljs-comment">//出队操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">//如果队列为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//返回-1</span><br>    }<br>    <span class="hljs-type">int</span> value = front-&gt;data; <span class="hljs-comment">//获取队头节点的数据域</span><br>    Node temp = front; <span class="hljs-comment">//创建临时指针指向队头节点</span><br>    front = front-&gt;next; <span class="hljs-comment">//队头指针指向下一个节点</span><br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>)<br>        rear = <span class="hljs-literal">nullptr</span>;<br>    temp-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//将临时指针的指针域置为空</span><br>    <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">//释放临时指针所指向的节点</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">//返回队头节点的数据域</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//入队10</span><br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//入队20</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl; <span class="hljs-comment">//出队并输出队头节点的数据域</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl; <span class="hljs-comment">//出队并输出队头节点的数据域</span><br>    <span class="hljs-built_in">enQueue</span>(<span class="hljs-number">30</span>); <span class="hljs-comment">//入队30</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl; <span class="hljs-comment">//出队并输出队头节点的数据域</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>() &lt;&lt; endl; <span class="hljs-comment">//出队并输出队头节点的数据域</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="chatgpt-代码-6">ChatGPT 代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> { <span class="hljs-comment">// 定义结构体node</span><br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* next; <span class="hljs-comment">// 指向下一个节点的指针</span><br>} node;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queue</span> { <span class="hljs-comment">// 定义结构体queue</span><br>    node* front; <span class="hljs-comment">// 队首指针</span><br>    node* rear; <span class="hljs-comment">// 队尾指针</span><br>} queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 初始化队列</span><br>    q.front = q.rear = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 队首和队尾指针均指向空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(queue&amp; q, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入队操作</span><br>    node* newNode = <span class="hljs-keyword">new</span> node; <span class="hljs-comment">// 创建新节点</span><br>    newNode-&gt;data = value; <span class="hljs-comment">// 赋值</span><br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 新节点的next指针指向空</span><br>    <span class="hljs-keyword">if</span> (q.rear == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果队列为空</span><br>        q.front = newNode; <span class="hljs-comment">// 队首指针指向新节点</span><br>        q.rear = newNode; <span class="hljs-comment">// 队尾指针指向新节点</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果队列不为空</span><br>        q.rear-&gt;next = newNode; <span class="hljs-comment">// 队尾节点的next指针指向新节点</span><br>        q.rear = newNode; <span class="hljs-comment">// 队尾指针指向新节点</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 出队操作</span><br>    <span class="hljs-keyword">if</span> (q.front == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果队列为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-type">int</span> value = q.front-&gt;data; <span class="hljs-comment">// 取出队首节点的值</span><br>    node* temp = q.front; <span class="hljs-comment">// 保存队首节点的指针</span><br>    q.front = q.front-&gt;next; <span class="hljs-comment">// 队首指针指向下一个节点</span><br>    <span class="hljs-keyword">if</span> (q.front == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果队列为空</span><br>        q.rear = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 队尾指针也指向空</span><br>    }<br>    <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">// 释放队首节点的内存</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回队首节点的值</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队首元素</span><br>    <span class="hljs-keyword">if</span> (q.front == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果队列为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> q.front-&gt;data; <span class="hljs-comment">// 返回队首节点的值</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rear</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队尾元素</span><br>    <span class="hljs-keyword">if</span> (q.rear == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果队列为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> q.rear-&gt;data; <span class="hljs-comment">// 返回队尾节点的值</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">return</span> q.front == <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果队首指针为空，则队列为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue q; <span class="hljs-comment">// 创建队列</span><br>    <span class="hljs-built_in">initQueue</span>(q); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">30</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">front</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队首元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">rear</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队尾元素</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">40</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">50</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(q) &lt;&lt; endl;<br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">60</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="老师教案补充-3">老师教案补充</h3><div class="row"><embed src="./队列Queue.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="拓展延申">拓展延申</h3><h4 id="基于栈实现的队列">基于栈实现的队列</h4><p>基于栈的队列被称为双栈队列（Double-Stack Queue），它使用两个栈来实现队列的功能。</p><p>在双栈队列中，入队操作只需要将元素压入第一个栈中；出队操作需要将第一个栈中的元素倒入第二个栈中，然后再弹出第二个栈的栈顶元素，这样就实现了出队操作。获取队头元素的操作也需要先将第一个栈中的元素倒入第二个栈中，然后获取第二个栈的栈顶元素。判断队列是否为空的操作需要判断两个栈是否都为空。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> {<br>    <span class="hljs-type">int</span>* data; <span class="hljs-comment">// 栈的数据</span><br>    <span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 栈的容量</span><br>} stack;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queue</span> {<br>    stack s1; <span class="hljs-comment">// 队列的第一个栈</span><br>    stack s2; <span class="hljs-comment">// 队列的第二个栈</span><br>} queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(stack&amp; s, <span class="hljs-type">int</span> capacity)</span> </span>{ <span class="hljs-comment">// 初始化栈</span><br>    s.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[capacity]; <span class="hljs-comment">// 为栈的数据分配内存</span><br>    s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈顶指针初始化为-1</span><br>    s.capacity = capacity; <span class="hljs-comment">// 栈的容量</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroyStack</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 销毁栈</span><br>    <span class="hljs-keyword">delete</span>[] s.data; <span class="hljs-comment">// 释放栈的数据内存</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> s.top == <span class="hljs-number">-1</span>; <span class="hljs-comment">// 栈顶指针为-1，说明栈为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否已满</span><br>    <span class="hljs-keyword">return</span> s.top == s.capacity - <span class="hljs-number">1</span>; <span class="hljs-comment">// 栈顶指针为栈的容量-1，说明栈已满</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(stack&amp; s, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>(s)) { <span class="hljs-comment">// 如果栈已满</span><br>        cout &lt;&lt; <span class="hljs-string">"Stack is full"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 返回</span><br>    }<br>    s.data[++s.top] = value; <span class="hljs-comment">// 栈顶指针加1，将数据入栈</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>(s)) { <span class="hljs-comment">// 如果栈为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Stack is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> s.data[s.top--]; <span class="hljs-comment">// 栈顶指针减1，返回栈顶数据</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">(stack&amp; s)</span> </span>{ <span class="hljs-comment">// 获取栈顶元素</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>(s)) { <span class="hljs-comment">// 如果栈为空</span><br>        cout &lt;&lt; <span class="hljs-string">"Stack is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>    }<br>    <span class="hljs-keyword">return</span> s.data[s.top]; <span class="hljs-comment">// 返回栈顶元素</span><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(queue&amp; q, <span class="hljs-type">int</span> capacity)</span> </span>{<br>    <span class="hljs-built_in">initStack</span>(q.s1, capacity); <span class="hljs-comment">// 初始化队列的第一个栈</span><br>    <span class="hljs-built_in">initStack</span>(q.s2, capacity); <span class="hljs-comment">// 初始化队列的第二个栈</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(queue&amp; q, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">push</span>(q.s1, value); <span class="hljs-comment">// 将元素入队</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 出队</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>(q.s2)) { <span class="hljs-comment">// 如果队列的第二个栈为空</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>(q.s1)) { <span class="hljs-comment">// 将队列的第一个栈中的元素出栈并入队到第二个栈中</span><br>            <span class="hljs-built_in">push</span>(q.s2, <span class="hljs-built_in">pop</span>(q.s1));<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop</span>(q.s2); <span class="hljs-comment">// 返回队首元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队首元素</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>(q.s2)) { <span class="hljs-comment">// 如果队列的第二个栈为空</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>(q.s1)) { <span class="hljs-comment">// 将队列的第一个栈中的元素出栈并入队到第二个栈中</span><br>            <span class="hljs-built_in">push</span>(q.s2, <span class="hljs-built_in">pop</span>(q.s1));<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">top</span>(q.s2); <span class="hljs-comment">// 返回队首元素</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rear</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 获取队尾元素</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isEmpty</span>(q.s1)) { <span class="hljs-comment">// 如果队列的第一个栈不为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">top</span>(q.s1); <span class="hljs-comment">// 返回队尾元素</span><br>    }<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isEmpty</span>(q.s2)) { <span class="hljs-comment">// 如果队列的第二个栈不为空</span><br>        <span class="hljs-keyword">return</span> q.s2.data[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 返回队尾元素</span><br>    }<br>    cout &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; endl; <span class="hljs-comment">// 输出提示信息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回-1</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isEmpty</span>(q.s1) &amp;&amp; <span class="hljs-built_in">isEmpty</span>(q.s2); <span class="hljs-comment">// 如果队列的第一个栈和第二个栈都为空，说明队列为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    queue q; <span class="hljs-comment">// 定义队列</span><br>    <span class="hljs-built_in">initQueue</span>(q, <span class="hljs-number">5</span>); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">20</span>); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-built_in">enQueue</span>(q, <span class="hljs-number">30</span>); <span class="hljs-comment">// 入队</span><br>    cout &lt;&lt; <span class="hljs-built_in">front</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队首元素并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">rear</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 获取队尾元素并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">deQueue</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 出队并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">isEmpty</span>(q) &lt;&lt; endl; <span class="hljs-comment">// 判断队列是否为空并输出</span><br>    <span class="hljs-built_in">destroyStack</span>(q.s1); <span class="hljs-comment">// 销毁队列的第一个栈</span><br>    <span class="hljs-built_in">destroyStack</span>(q.s2); <span class="hljs-comment">// 销毁队列的第二个栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="基于队列实现的栈">基于队列实现的栈</h4><p>基于队列的基本的栈实现需要使用两个队列来完成，我们称之为入队队列和出队队列。假设当前的栈非空，所有的元素都在入队队列中。</p><p>当入栈操作时，我们向入队队列中插入一个元素。</p><p>当出栈操作时，我们先把入队队列中除了队尾元素以外的所有元素出队并插入到出队队列中，然后将队尾元素出队并返回。</p><p>下一次的入栈操作仍然向入队队列中插入元素，而出栈操作则是从出队队列中取出元素。</p><p>这样的话，每次出栈操作都需要将除了队尾元素以外的所有元素从一个队列中转移到另一个队列中，效率较低，但是对于单次操作数较少的栈操作来说还是可行的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Queue</span> {<br>    <span class="hljs-type">int</span> data[MAX_SIZE]; <span class="hljs-comment">// 队列的数据</span><br>    <span class="hljs-type">int</span> front; <span class="hljs-comment">// 队头</span><br>    <span class="hljs-type">int</span> rear; <span class="hljs-comment">// 队尾</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(Queue&amp; q)</span> </span>{ <span class="hljs-comment">// 初始化队列</span><br>    q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队头和队尾都为0</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isQueueEmpty</span><span class="hljs-params">(Queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">return</span> q.front == q.rear; <span class="hljs-comment">// 队头和队尾相等，队列为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isQueueFull</span><span class="hljs-params">(Queue&amp; q)</span> </span>{ <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-keyword">return</span> (q.rear + <span class="hljs-number">1</span>) % MAX_SIZE == q.front; <span class="hljs-comment">// 队尾+1等于队头，队列已满</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(Queue&amp; q, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入队</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isQueueFull</span>(q)) { <span class="hljs-comment">// 如果队列已满，直接返回</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    q.data[q.rear] = value; <span class="hljs-comment">// 将数据存入队尾</span><br>    q.rear = (q.rear + <span class="hljs-number">1</span>) % MAX_SIZE; <span class="hljs-comment">// 队尾+1</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(Queue&amp; q)</span> </span>{ <span class="hljs-comment">// 出队</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isQueueEmpty</span>(q)) { <span class="hljs-comment">// 如果队列为空，返回-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> value = q.data[q.front]; <span class="hljs-comment">// 取出队头的数据</span><br>    q.front = (q.front + <span class="hljs-number">1</span>) % MAX_SIZE; <span class="hljs-comment">// 队头+1</span><br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回队头的数据</span><br>}<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span> { <span class="hljs-comment">// 定义栈</span><br>    Queue q1; <span class="hljs-comment">// 定义队列1</span><br>    Queue q2; <span class="hljs-comment">// 定义队列2</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(Stack&amp; s)</span> </span>{ <span class="hljs-comment">// 初始化栈</span><br>    <span class="hljs-built_in">initQueue</span>(s.q1); <span class="hljs-comment">// 初始化队列1</span><br>    <span class="hljs-built_in">initQueue</span>(s.q2); <span class="hljs-comment">// 初始化队列2</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isStackEmpty</span><span class="hljs-params">(Stack&amp; s)</span> </span>{ <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isQueueEmpty</span>(s.q1) &amp;&amp; <span class="hljs-built_in">isQueueEmpty</span>(s.q2); <span class="hljs-comment">// 如果队列1和队列2都为空，栈为空</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack&amp; s, <span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isQueueFull</span>(s.q1) || <span class="hljs-built_in">isQueueFull</span>(s.q2)) { <span class="hljs-comment">// 如果队列1或队列2已满，直接返回</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isQueueEmpty</span>(s.q1)) { <span class="hljs-comment">// 如果队列1不为空</span><br>        <span class="hljs-built_in">enQueue</span>(s.q1, value); <span class="hljs-comment">// 将数据入队到队列1</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果队列1为空</span><br>        <span class="hljs-built_in">enQueue</span>(s.q2, value); <span class="hljs-comment">// 将数据入队到队列2</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack&amp; s)</span> </span>{ <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isStackEmpty</span>(s)) { <span class="hljs-comment">// 如果栈为空，返回-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isQueueEmpty</span>(s.q1)) { <span class="hljs-comment">// 如果队列1不为空</span><br>        <span class="hljs-keyword">while</span> (s.q1.front != s.q1.rear - <span class="hljs-number">1</span>) { <span class="hljs-comment">// 将队列1中除队尾外的数据全部出队并入队到队列2</span><br>            <span class="hljs-built_in">enQueue</span>(s.q2, <span class="hljs-built_in">deQueue</span>(s.q1));<br>        }<br>        value = <span class="hljs-built_in">deQueue</span>(s.q1); <span class="hljs-comment">// 取出队列1的队尾数据</span><br>    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果队列1为空</span><br>        <span class="hljs-keyword">while</span> (s.q2.front != s.q2.rear - <span class="hljs-number">1</span>) { <span class="hljs-comment">// 将队列2中除队尾外的数据全部出队并入队到队列1</span><br>            <span class="hljs-built_in">enQueue</span>(s.q1, <span class="hljs-built_in">deQueue</span>(s.q2));<br>        }<br>        value = <span class="hljs-built_in">deQueue</span>(s.q2); <span class="hljs-comment">// 取出队列2的队尾数据</span><br>    }<br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回队尾的数据</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Stack s;<br>    <span class="hljs-built_in">initStack</span>(s); <span class="hljs-comment">// 初始化栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">20</span>); <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">30</span>); <span class="hljs-comment">// 入栈</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出</span><br>    <span class="hljs-built_in">push</span>(s, <span class="hljs-number">40</span>); <span class="hljs-comment">// 入栈</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出</span><br>    cout &lt;&lt; <span class="hljs-built_in">pop</span>(s) &lt;&lt; endl; <span class="hljs-comment">// 出栈并输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="树">树</h2><p>树（Tree）是一种非线性的数据结构，由节点（node）和边（edge）组成。树结构具有一个根节点（root），根节点下面可以有若干个子节点（child node），子节点又可以有自己的子节点，形成一棵树状结构。每个节点可以有多个子节点，但只能有一个父节点（parent node），并且节点之间不存在循环引用，即不存在一个节点的子孙节点指向该节点本身。基本上所有的数据库都是基于树的。</p><h3 id="树的层数高度和深度">树的层数、高度和深度</h3><p>当涉及到树的层数、高度和深度时，容易混淆。下面的 Markdown 表格可以帮助你理解它们之间的区别：</p><table><thead><tr class="header"><th style="text-align:center">术语</th><th style="text-align:center">定义</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">高度</td><td style="text-align:center">从根节点到最远叶子节点的距离（沿最长路径）</td></tr><tr class="even"><td style="text-align:center">深度</td><td style="text-align:center">从根节点到某个节点的距离（沿树的任意路径）</td></tr><tr class="odd"><td style="text-align:center">层数</td><td style="text-align:center">节点的深度加 1（根节点的层数为 1）</td></tr></tbody></table><p>举个例子，对于下面这棵树：</p><figure class="highlight livescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     A<br>   / | <span class="hljs-string">\</span><br>  B  C  D<br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br>E   F G   H<br>       <span class="hljs-string">\</span><br>        I<br></code></pre></td></tr></tbody></table></figure><p>根节点 A 的高度（深度）为 3，节点 I 的深度为 4，节点 I 的层数为 5。注意，节点的层数始终比它的深度大 1，因为根节点的层数为 1。</p><h3 id="二叉树">二叉树</h3><p>二叉树是一种特殊的树结构，其中每个节点最多只有两个子节点。根据二叉树的性质，我们可以将其分为以下几种：</p><ol type="1"><li><strong>满二叉树（Full Binary Tree）</strong>：除了叶子节点外，每个节点都有两个子节点，且所有叶子节点都在同一层次上。</li><li><strong>完全二叉树（Complete Binary Tree）</strong>：除了最后一层外，每一层都被完全填满，且所有节点都向左对齐。最后一层可以不满，但是所有节点必须集中在左侧。</li><li><strong>二叉搜索树（Binary Search Tree，BST）</strong>：每个节点都比它的左子节点大，比它的右子节点小（或相等）。这个性质使得二叉搜索树可以进行高效的查找、插入和删除操作。</li><li><strong>平衡二叉树（Balanced Binary Tree）</strong>：左右子树的高度差不超过 1 的二叉树。平衡二叉树可以保证各种操作的时间复杂度为 O(log n)，其中 n 为节点数量。</li><li><strong>线索二叉树（Threaded Binary Tree）</strong>：对二叉树的中序遍历进行修改，将每个节点的空指针指向它的前驱或后继节点，从而将二叉树变为一个线性的数据结构，方便遍历。</li><li><strong>哈夫曼树（Huffman Tree）</strong>：用于数据压缩算法中，根据字符出现频率构建一棵满足最优编码长度的二叉树。</li></ol><p>除了上述六种二叉树，还有一些其他的二叉树类型，如红黑树、B 树等。这些二叉树都具有不同的特点和应用场景，选择合适的二叉树类型可以提高算法效率和性能。</p><h4 id="常见的二叉树">常见的二叉树</h4><table><thead><tr class="header"><th style="text-align:center">二叉树类型</th><th style="text-align:center">定义</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">满二叉树</td><td style="text-align:center">除了叶子节点外，每个节点都有两个子节点，且所有叶子节点都在同一层次上</td></tr><tr class="even"><td style="text-align:center">完全二叉树</td><td style="text-align:center">除了最后一层外，每一层都被完全填满，且所有节点都向左对齐。最后一层可以不满，但是所有节点必须集中在左侧</td></tr><tr class="odd"><td style="text-align:center">二叉搜索树</td><td style="text-align:center">每个节点都比它的左子节点大，比它的右子节点小（或相等）。这个性质使得二叉搜索树可以进行高效的查找、插入和删除操作</td></tr><tr class="even"><td style="text-align:center">平衡二叉树</td><td style="text-align:center">左右子树的高度差不超过 1 的二叉树。平衡二叉树可以保证各种操作的时间复杂度为 O(log n)，其中 n 为节点数量</td></tr><tr class="odd"><td style="text-align:center">线索二叉树</td><td style="text-align:center">对二叉树的中序遍历进行修改，将每个节点的空指针指向它的前驱或后继节点，从而将二叉树变为一个线性的数据结构，方便遍历</td></tr><tr class="even"><td style="text-align:center">哈夫曼树</td><td style="text-align:center">用于数据压缩算法中，根据字符出现频率构建一棵满足最优编码长度的二叉树</td></tr></tbody></table><p>需要注意的是，以上仅列举了常见的二叉树类型，实际上还有许多其他的二叉树类型，如 AVL 树、红黑树、B 树等，每种类型都有其独特的特点和应用场景。</p><h4 id="二叉树的遍历">二叉树的遍历</h4><p>二叉树的遍历是指按照一定顺序依次访问二叉树的所有节点。常见的二叉树遍历方式有三种：前序遍历、中序遍历和后序遍历。下面我将分别介绍这三种遍历方式。</p><ol type="1"><li>前序遍历：按照“根节点-左子树-右子树”的顺序访问二叉树中的所有节点。具体实现方法是先访问根节点，再对左子树进行前序遍历，最后对右子树进行前序遍历。</li><li>中序遍历：按照“左子树-根节点-右子树”的顺序访问二叉树中的所有节点。具体实现方法是先对左子树进行中序遍历，再访问根节点，最后对右子树进行中序遍历。</li><li>后序遍历：按照“左子树-右子树-根节点”的顺序访问二叉树中的所有节点。具体实现方法是先对左子树进行后序遍历，再对右子树进行后序遍历，最后访问根节点。</li></ol><p>下面是一个用示意图表示的二叉树，以及其前、中、后序遍历的过程：</p><figure class="highlight livescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">1</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">5</span> <span class="hljs-number">6</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>前序遍历：1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p><p>具体实现方法是先访问根节点 1，然后递归地对左子树 2-4 进行前序遍历，再递归地对右子树 3-6 进行前序遍历，最后访问节点 7。</p></li><li><p>中序遍历：4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p><p>具体实现方法是先递归地对左子树 4-2 进行中序遍历，然后访问根节点 1，最后递归地对右子树 6-7 进行中序遍历。</p></li><li><p>后序遍历：4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</p><p>具体实现方法是先递归地对左子树 4-5 进行后序遍历，然后递归地对右子树 6-7 进行后序遍历，最后访问根节点 1。</p></li></ul><p>需要注意的是，前、中、后序遍历是针对根节点的访问顺序而言的，对于每个节点而言，它的左子树、右子树也需要按照相应的遍历方式进行访问。同时，由于二叉树的遍历是递归</p><table><thead><tr class="header"><th>遍历方式</th><th>访问顺序</th><th>具体实现方法</th></tr></thead><tbody><tr class="odd"><td>前序遍历</td><td>根节点-左子树-右子树</td><td>先访问根节点，再对左子树进行前序遍历，最后对右子树遍历</td></tr><tr class="even"><td>中序遍历</td><td>左子树-根节点-右子树</td><td>先对左子树进行中序遍历，再访问根节点，最后对右子树遍历</td></tr><tr class="odd"><td>后序遍历</td><td>左子树-右子树-根节点</td><td>先对左子树进行后序遍历，再对右子树进行后序遍历，最后访问根节点</td></tr></tbody></table><h5 id="中序遍历的投影法">中序遍历的投影法</h5><p>直接把所有节点拉到同一行上，从左往右就是这棵树的中序遍历的访问顺序</p><h5 id="前序遍历的投影法">前序遍历的投影法</h5><p>先把树逆时针旋转九十度，再把所有节点拉到同一行上（且顺序为根、左子树、右子树），从左往右就是这棵树的中序遍历的访问顺序</p><h5 id="后序遍历的投影法">后序遍历的投影法</h5><p>先把树顺时针旋转九十度，再把所有节点拉到同一行上（且顺序为左子树、右子树、根），从左往右就是这棵树的中序遍历的访问顺序</p><h3 id="二叉树的创建">二叉树的创建</h3><p>在二叉树的创建中，可以采用询问法来构建二叉树。具体过程如下：</p><ol type="1"><li>首先创建一个根节点，并将其设为当前节点。</li><li>对于当前节点，询问用户是否需要添加左子节点，如果需要，则创建左子节点，并将其设为当前节点；如果不需要，则跳过此步骤。</li><li>对于当前节点，询问用户是否需要添加右子节点，如果需要，则创建右子节点，并将其设为当前节点；如果不需要，则跳过此步骤。</li><li>如果当前节点有父节点，则将当前节点设为其父节点，并回到步骤 2，否则结束。</li></ol><p>在询问法创建二叉树的过程中，用户可以根据需要添加左右子节点，从而构建出一棵任意形状的二叉树。需要注意的是，询问法创建的二叉树不一定是平衡的，因此可能存在查找、插入、删除等操作的时间复杂度较高的问题。如果需要创建平衡二叉树，则需要采用其他方式，如通过已有数据构建平衡二叉树或者采用特殊的平衡二叉树构建算法（如 AVL 树、红黑树等）。</p><h3 id="二叉搜索树">二叉搜索树</h3><p>二叉搜索树（Binary Search Tree，简称 BST）是一种特殊的二叉树，它的每个节点都满足以下条件：</p><ol type="1"><li>左子树上所有节点的值都小于该节点的值。</li><li>右子树上所有节点的值都大于该节点的值。</li><li>左右子树也分别为二叉搜索树。</li></ol><p>如果二叉排序树是平衡的，则 n 个节点的二叉排序树的高度为<span class="math inline">\(\log_2 n + 1\)</span>,其查找效率为 O(log<sub>2</sub>n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到 n，查找效率为 O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在 O(log<sub>2</sub>n)到 O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></tbody></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a> <a href="/tags/%E8%80%83%E7%A0%94/" class="print-no-link">#考研</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a></div></div><div class="license-box my-3"><div class="license-title"><div>数据结构笔记</div><div>https://meteorandy.netlify.app/posts/928debf2/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>流星胖胖（MeteorAndy）</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/bc1c130a/" title="蓝桥杯刷题笔记（大学Web组）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">蓝桥杯刷题笔记（大学Web组）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/62583/" title="信息技术补充"><span class="hidden-mobile">信息技术补充</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"DpHUGCpJskfsvul9py9gnP22-9Nh9j0Va",appKey:"lIWlKO4kQ2PL8vpNLiY2uFNy",path:"window.location.pathname",placeholder:"欢迎评论~~~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script></body></html>