<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo/guoba.png"><link rel="icon" href="/img/logo/guoba.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#A90113"><meta name="author" content="流星胖胖（MeteorAndy）"><meta name="keywords" content=""><meta name="description" content="865 数据结构与程序设计 第一章 概论 1. 数据结构的基本概念与术语  基本概念  数据 数据元素、数据项 数据对象、数据结构 数据类型、抽线数据类型（ADT）  三要素  逻辑结构  集合 线性结构  一对一  树形结构  一对多  图结构（网状结构）  多对多   数据的运算  结构逻辑结构、实际需求来定义基本运算  物理结构（存储结构）  顺序存储 链式存储 索引存储 散列存储    2"><meta property="og:type" content="article"><meta property="og:title" content="865 数据结构与程序设计"><meta property="og:url" content="https://meteorandy.netlify.app/posts/24976/index.html"><meta property="og:site_name" content="流星胖胖的小角落"><meta property="og:description" content="865 数据结构与程序设计 第一章 概论 1. 数据结构的基本概念与术语  基本概念  数据 数据元素、数据项 数据对象、数据结构 数据类型、抽线数据类型（ADT）  三要素  逻辑结构  集合 线性结构  一对一  树形结构  一对多  图结构（网状结构）  多对多   数据的运算  结构逻辑结构、实际需求来定义基本运算  物理结构（存储结构）  顺序存储 链式存储 索引存储 散列存储    2"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/b3340bdb2ed028da4ecc1cfcbc5f6cc93adcf87271481e7150673f4a7678ba96.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/73d6181709a8d0bbb4bb0349fc454fca9bc296acda4ee9071bec44af18c2a2d3.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/b3340bdb2ed028da4ecc1cfcbc5f6cc93adcf87271481e7150673f4a7678ba96.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/73d6181709a8d0bbb4bb0349fc454fca9bc296acda4ee9071bec44af18c2a2d3.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/434016643f3ad5498e487f14fb84f7407acc0505b5b56a29b9012eb9b53119f6.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/6792de4fb40e0fb34484da84a8dc569582f11b28dff430a2fce452b999f33353.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/021b8d2aa9f1f69e092d48ad431f16025edc1a5adc14735d5b671fde0631f632.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/3fc445370720dba5b2e3147eb0bab4bce8b97e15c79abf6f143cc39b8fc3152d.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/0b9f8dc717d5c34a928d3754222619e94900d8ab9c19639a48efa92e02b321e0.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/dc5b8d8726a6401fa44f1ecc38a76eeef64294127337049ccb21eb75a51ebfc1.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/34f6a5775cb461bc8bbb559f7d7b3d1e19b5eebf8ce49e213057f68bd9a722c6.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/f7a05267c53c5c5a20ddc7b9c456939cc41a72d46b5dd8b2755dc09d34f29709.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/b00619f7a7b945502524b82173724a5cf72ca2cac2153b461b44276fcab08ee0.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/15f8aca1c35e14a1290ead386b6874d112e4e5c00aa0290054871272f2ae653b.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/d87c46606aae3c356f8e3c700f6b0b0bb493c22a131c927f6f5c783c84d4f4fe.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/580a1bc05381de4479b9567079e0af008519f1b84d1e9744f6d62b8700a4f1cd.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/5509c85f9f66f7659a01d0d78b51a6e053a1a0091187c6d782682ad8fbca51ff.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/bfdd5b3f75b792cba75544406ac7c34405766f840e873c683197aafb1e2dbeb2.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/f7875ec4c4604df9fe7a8ef340b29953b476ff5386ffe67bf98b4011c27eb9e6.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/c96ae0d31ad47abad36ec269e57c73f305cf90db65e184b0c9f16f4cc949e1dd.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/f025acaa886a38d66fc57a807665c66bb9afa369863125907d8c4c2273728f0a.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/245eaa21a284ec51189935e18f99a3995bf061fafdb392978bbdc11e0b3fe390.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/5de9e12ee83ba2bcf42c033add5c043022001b9344ab05541fb4c4b44a395f7a.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/180f6e97774394caf48c081ea93e84681f83477598301b8f61e0fd51a29d4c7f.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/926de10ec595f3b744105d39f490f09ba720d6269278b81433084f01fba08d77.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/eeb62ee5422e9a46941665e872cb2f11d539c319f496d9edaf6830eda2c3a404.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/2ce80a67e4a79719d250723fad942d01e664f11f31c121359f106e3e561b9c64.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/c54b7d231c4312cc097b36ac1189b483336b632818f3c122e4a51981e79575a1.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/a6c2d85bace4dd7c58dad19f89760796d5b2d4674601aa859ed49bc84fa33811.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/404b653bb1bd189baa31d2f895852a1c1f30415eb37e13f81a99c6d69cf1cc40.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/dd4808e2458876718d2e94c4e1a6957312d9ade27dd5f2e8702d228e11d78f95.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/f2a5a29ab31152461fffc83462bf5e4100033f7932925f5883a4fe7f06eae4cf.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/895e5737ac16e172fc9f80d2d31facf3964c3f381a5d0d6f12a37f1df601479d.png"><meta property="og:image" content="https://meteorandy.netlify.app/posts/24976/%E5%AE%8C%E6%95%B4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"><meta property="article:published_time" content="2023-11-26T10:20:11.000Z"><meta property="article:modified_time" content="2024-06-27T00:58:19.587Z"><meta property="article:author" content="流星胖胖（MeteorAndy）"><meta property="article:tag" content="学习"><meta property="article:tag" content="考研"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://meteorandy.netlify.app/posts/24976/b3340bdb2ed028da4ecc1cfcbc5f6cc93adcf87271481e7150673f4a7678ba96.png"><title>865 数据结构与程序设计 - 流星胖胖的小角落</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"meteorandy.netlify.app",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!0,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#A90113",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:null,tencent:{sid:null,cid:null},leancloud:{app_id:"DpHUGCpJskfsvul9py9gnP22-9Nh9j0Va",app_key:"lIWlKO4kQ2PL8vpNLiY2uFNy",server_url:"https://dphugcpj.lc-cn-e1-shared.com",path:"window.location.pathname",ignore_local:!0},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null},gtag:null,woyaola:null,cnzz:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>流星胖胖的小角落</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/workshop.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="865 数据结构与程序设计"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-11-26 18:20" pubdate>2023年11月26日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 106 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">865 数据结构与程序设计</h1><div class="markdown-body"><h1 id="数据结构与程序设计">865 数据结构与程序设计</h1><h2 id="第一章-概论">第一章 概论</h2><h3 id="数据结构的基本概念与术语">1. 数据结构的基本概念与术语</h3><ul><li><p>基本概念</p><ul><li>数据</li><li>数据元素、数据项</li><li>数据对象、数据结构</li><li>数据类型、抽线数据类型（ADT）</li></ul></li><li><p>三要素</p><ul><li><p>逻辑结构</p><ul><li><p>集合</p></li><li><p>线性结构</p><ul><li>一对一</li></ul></li><li><p>树形结构</p><ul><li>一对多</li></ul></li><li><p>图结构（网状结构）</p><ul><li>多对多</li></ul></li></ul></li><li><p>数据的运算</p><ul><li>结构逻辑结构、实际需求来定义基本运算</li></ul></li><li><p>物理结构（存储结构）</p><ul><li>顺序存储</li><li>链式存储</li><li>索引存储</li><li>散列存储</li></ul></li></ul></li></ul><h3 id="算法与算法分析">2. 算法与算法分析</h3><ul><li><p>算法的基本概念</p><ul><li><p>什么是算法</p><ul><li><p>程序=数据结构+算法</p><ul><li>数据结构是要处理的信息</li><li>算法是处理信息的步骤</li></ul></li></ul></li><li><p>算法的五个特性</p><ul><li><p>有穷性</p><ul><li><p>有穷时间内能执行完</p><ul><li>算法是有穷的</li><li>程序可以是无穷的</li></ul></li></ul></li><li><p>确定性</p><ul><li>相同输入只会产生相同输出</li></ul></li><li><p>可行性</p><ul><li>可以用已有的基本操作实现算法</li></ul></li><li><p>输入</p><ul><li>丢给算法处理的数据</li></ul></li><li><p>输出</p><ul><li>算法处理的结果</li></ul></li></ul></li><li><p>“好”算法的特质</p><ul><li><p>正确性</p></li><li><p>可读性</p></li><li><p>健壮性</p></li><li><p>高效率与低存储量需求</p><ul><li>即算法执行省时、省内存</li><li>时间复杂度低、空间复杂度低</li></ul></li></ul></li></ul></li><li><p>时间复杂度</p><ul><li><p>如何计算</p><ul><li>① 找到一个基本操作（最深层循环）</li><li>② 分析该基本操作的执行次数 x 与问题规模 n 的关系 x=f(n)</li><li>③x 的数量级 O(x)就是算法时间复杂度 T(n)</li></ul></li><li><p>常用技巧</p><ul><li>加法规则： <img src="b3340bdb2ed028da4ecc1cfcbc5f6cc93adcf87271481e7150673f4a7678ba96.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>乘法规则： <img src="73d6181709a8d0bbb4bb0349fc454fca9bc296acda4ee9071bec44af18c2a2d3.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li><li><p>三种复杂度</p><ul><li>最坏时间复杂度：考虑输入数据“最坏”的情况</li><li>平均时间复杂度：考虑所有输入数据都等概率出现的情况</li><li>最好时间复杂度：考虑输入数据“最好”的情况</li></ul></li></ul></li><li><p>空间复杂度</p><ul><li><p>如何计算</p><ul><li><p>普通程序</p><ul><li>① 找到所占空间大小与问题规模相关的变量</li><li>② 分析所占看见 x 与问题规模 n 的关系 x=f(n)</li><li>③x 的数量级 O(x)就是算法空间复杂度 S(n)</li></ul></li><li><p>递归程序</p><ul><li>① 找到递归调用的深度 x 与问题规模 n 的关系 x=f(n)</li><li>②x 的数量级 O(x)就算算法空间复杂度 S(n)</li><li>注：有的算法各层函数所需存储空间不同，分析方法略有区别</li></ul></li></ul></li><li><p>常用技巧</p><ul><li>加法规则： <img src="b3340bdb2ed028da4ecc1cfcbc5f6cc93adcf87271481e7150673f4a7678ba96.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>乘法规则： <img src="73d6181709a8d0bbb4bb0349fc454fca9bc296acda4ee9071bec44af18c2a2d3.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li></ul></li></ul><h2 id="第二章-线性表及其顺序存储">第二章 线性表及其顺序存储</h2><h3 id="线性表">1. 线性表</h3><ul><li><p>定义</p><ul><li><p>值得注意的特性</p><ul><li>数据元素同类型、有限、有序</li></ul></li><li><p>重要术语</p><ul><li>表长、空表</li><li>表头、表尾</li><li>前驱、后继</li><li>数据元素的位序（从 1 开始） 用数组实现线性表时需要注意审题</li></ul></li></ul></li><li><p>基本操作</p><ul><li><p>创销、增删改查（所有数据结构适用的记忆思路）</p></li><li><p>判空、判长、打印输出（还可自己根据实际需求增加其他基本操作）</p></li><li><p>其他值得注意的点</p><ul><li>理解什么时候要传入参数的引用“&amp;”</li><li>函数命名要有可读性</li></ul></li></ul></li></ul><h3 id="顺序表及其应用">2. 顺序表及其应用</h3><ul><li><p>定义</p><ul><li><p>存储结构</p><ul><li>逻辑上相邻的数据元素物理上也相邻</li></ul></li><li><p>实现方式</p><ul><li><p>静态分配</p><ul><li>使用“静态数组”实现</li><li>大小一旦确定就无法改变</li></ul></li><li><p>动态分配</p><ul><li>使用“动态数组实现”</li><li>L.data = (ElemType <em>) malloc (sizeof(ElemType) </em>size);</li><li>顺序表存满时，可再用 malloc 动态拓展顺序表的最大容量</li><li>需要将数据元素复制到新的存储区域，并用 free 函数释放原区域</li></ul></li></ul></li><li><p>特点</p><ul><li><p>随机访问</p><ul><li>能在 O(1)时间内找到第 i 个元素</li></ul></li><li><p>存储密度高</p></li><li><p>拓展容量不方便</p></li><li><p>插入、删除数据元素不方便</p></li></ul></li></ul></li><li><p>基本操作</p><ul><li><p>插入</p><ul><li><p>ListInsert(&amp;L,i,e)</p><ul><li>将元素 e 拆入到 L 的第 i 个位置</li></ul></li><li><p>插入位置之后的元素都要后移</p></li><li><p>时间复杂度</p><ul><li>最好 O(1)、最坏 O(n)、平均 O(n)</li></ul></li></ul></li><li><p>删除</p><ul><li><p>ListDelete(&amp;L,i,&amp;e)</p><ul><li>将 L 的第 i 个元素删除，并用 e 返回</li></ul></li><li><p>删除位置之后的元素都要前移</p></li><li><p>时间复杂度</p><ul><li>最好 O(1)、最坏 O(n)、平均 O(n)</li></ul></li></ul></li><li><p>代码要点</p><ul><li>代码中注意位序 i 和数组下标的区别</li><li>算法要有健壮性，注意判断 i 的合法性</li><li>分析代码，理解为什么有的参数需要加“&amp;”引用</li></ul></li></ul></li></ul><h3 id="栈的概念及其应用">3. 栈的概念及其应用</h3><ul><li><p>定义</p><ul><li>一种操作受限的线性表，只能在栈顶插入、删除</li><li>特性：后进先出（LIFO）</li><li>术语：栈顶、栈底、空栈</li></ul></li><li><p>基本操作</p><ul><li>创、销</li><li>增、删（元素进栈、出栈，只能在栈顶操作）</li><li>查（获得栈顶元素，但不删除）</li><li>判空</li></ul></li><li><p>顺序栈</p><ul><li><p>顺序存储，用静态数组实现，并需要记录栈顶指针</p></li><li><p>基本操作</p><ul><li>创、增、删、查（都是 O(1)时间复杂度）</li></ul></li><li><p>两种实现</p><ul><li><p>初始化时 top=-1</p><ul><li><p>入栈</p><ul><li>S.data[++S.top]=x;</li></ul></li><li><p>出栈</p><ul><li>x=S.data[S.top--];</li></ul></li><li><p>获得栈顶元素</p><ul><li>x=S.data[S.top];</li></ul></li><li><p>栈空/栈满条件是？</p></li></ul></li><li><p>初始化时 top=0</p><ul><li><p>入栈</p><ul><li>S.data[S.top++]=x;</li></ul></li><li><p>出栈</p><ul><li>x=S.data[--S.top];</li></ul></li><li><p>获得栈顶元素</p><ul><li>x=S.data[S.top-1];</li></ul></li><li><p>栈空/栈满条件是？</p></li></ul></li></ul></li><li><p>共享栈</p><ul><li><p>两个栈共享同一片内存空间，两个栈从两边往中间增长</p></li><li><p>初始化</p><ul><li>0 号栈栈顶指针初始时 top0=-1; 1 号栈栈顶指针初始时 top1=MaxSize;</li></ul></li><li><p>栈满条件</p><ul><li>top0+1==top1;</li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>栈在括号匹配中的应用</p><ul><li>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配</li></ul></li><li><p>栈在表达式求值问题中的应用 <img src="434016643f3ad5498e487f14fb84f7407acc0505b5b56a29b9012eb9b53119f6.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li><p>概念</p><ul><li>运算符、操作数、界限符（DIY 概念：左操作数/右操作数）</li></ul></li><li><p>三种表达式</p><ul><li><p>中缀表达式</p><ul><li>运算符在操作数中间</li></ul></li><li><p>后缀表达式（逆波兰式）</p><ul><li>运算符在操作数后面</li></ul></li><li><p>前缀表达式（波兰式）</p><ul><li>运算符在操作数前面</li></ul></li></ul></li><li><p>后缀表达式考点</p><ul><li><p>中缀转后缀</p><ul><li>① 按”左优先“原则确定运算符的运算次序</li><li>② 根据 ① 中确定的次序，依次将各个运算符和与之相邻的两个操作数按&lt;左操作数 右操作数 运算符&gt;的规则合体</li></ul></li><li><p>后缀转中缀</p><ul><li>从左往右扫描，每遇到一个运算符，就将&lt;左操作数 右操作数 运算符&gt;变为（左操作数 运算符 右操作数）的形式</li></ul></li><li><p>计算</p><ul><li>从左往右扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是”右操作数“）</li></ul></li></ul></li><li><p>前缀表达式</p><ul><li><p>中缀转前缀</p><ul><li>① 按”右优先“原则确定运算符的运算次序</li><li>② 根据 ① 中确定的次序，依次将各个运算符和与之相邻的两个操作数按&lt;运算符 左操作数 右操作数&gt;的规则合体</li></ul></li><li><p>计算</p><ul><li>从右往左扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是”左操作数“）</li></ul></li></ul></li></ul></li><li><p>栈在递归中的应用 <img src="6792de4fb40e0fb34484da84a8dc569582f11b28dff430a2fce452b999f33353.png" srcset="/img/loading.gif" lazyload alt="image"></p></li></ul></li></ul><h3 id="队列的概念及其应用">4. 队列的概念及其应用</h3><ul><li><p>定义</p><ul><li>一种操作受限的线性表，只能在队尾插入、在队头删除</li><li>特性：先进先出（FIFO）</li><li>术语：队头、队尾、空队列、队头元素、队尾元素</li></ul></li><li><p>基本操作</p><ul><li>创、销</li><li>增、删（入队、出队，只能在规定的一端进行）</li><li>查（获得队头元素，但不删除）</li><li>判空</li></ul></li><li><p>顺序队列</p><ul><li><p>实现思想</p><ul><li>用静态数组存放数据元素，设置队头/队尾（front/rear）指针</li><li>循环队列：用模运算（取余）将存储空间在逻辑上变为“环状”</li><li>Q.rear=(Q.rear+1)%MaxSize</li></ul></li><li><p>重要考点</p><ul><li>如何初始化、入队、出队</li><li>如何判空、判满</li><li>如何计算队列的长度</li></ul></li><li><p>分析思路</p><ul><li><p>确定 front、rear 指针的指向</p><ul><li>①rear 指向队尾元素后一个位置</li><li>②rear 指向队尾元素</li></ul></li><li><p>确定判空、判满的方法</p><ul><li><ol type="a"><li>牺牲一个存储单元</li></ol></li><li><ol start="2" type="a"><li>增加 size 遍历记录队列长度</li></ol></li><li>c, 增加 tag=0/1 用于标记最近的一次操作是出队/入队</li></ul></li></ul></li></ul></li><li><p>队列的变种</p><ul><li><p>双端队列</p><ul><li>允许从两端插入、两端删除的队列</li></ul></li><li><p>输入受限的双端队列</p><ul><li>允许从两端删除、从一端插入的队列</li></ul></li><li><p>输出受限的双端队列</p><ul><li>允许从两端插入、从一端删除的队列</li></ul></li><li><p>考点：对输出序列合法性的判断</p></li></ul></li><li><p>队列在操作系统中的应用 <img src="021b8d2aa9f1f69e092d48ad431f16025edc1a5adc14735d5b671fde0631f632.png" srcset="/img/loading.gif" lazyload alt="image"></p></li></ul><h2 id="第三章-线性表及其链式存储">第三章 线性表及其链式存储</h2><h3 id="链式存储">1. 链式存储</h3><h3 id="单链表">2. 单链表</h3><ul><li><p>定义</p><ul><li><p>单链表</p><ul><li>用“链式存储”（存储结构）实现了“线性结构”（逻辑结构）</li><li>一个结点存储一个数据元素</li><li>各结点间的先后关系用一个指针表示</li></ul></li><li><p>用代码定义一个单链表</p></li><li><p>两种实现</p><ul><li><p>不带头结点</p><ul><li>空表判断：L==NULL。写代码不方便</li></ul></li><li><p>带头结点</p><ul><li>空表判断：L-&gt;next==NULL。写代码更方便</li></ul></li></ul></li><li><p>其他值得注意的点</p><ul><li>typedef 关键字的用法</li><li>“LinkList”等价于“LNode *” 前者强调这是链表，后者强调这是结点 合适的地方使用合适的名字，代码可读性更高</li></ul></li></ul></li><li><p>基本操作</p><ul><li><p>插入</p><ul><li><p>按位序插入</p><ul><li>不带头结点</li><li>带头结点</li></ul></li><li><p>指定结点的后插操作</p></li><li><p>指定结点的前插操作</p></li></ul></li><li><p>删除</p><ul><li>按位序删除</li><li>指定结点的删除</li></ul></li><li><p>建立</p><ul><li><p>头插法</p><ul><li>重要应用：链表的逆置</li></ul></li><li><p>尾插法</p></li></ul></li></ul></li></ul><h3 id="带头结点的单链表及其应用">3. 带头结点的单链表及其应用</h3><h3 id="循环单链表与双链表">4. 循环单链表与双链表</h3><ul><li><p>双链表</p><ul><li><p>初始化</p><ul><li>头结点的 prior、next 都指向 NULL</li></ul></li><li><p>插入（后插）</p><ul><li>注意新插入结点、前驱结点、后继结点的指针修改</li><li>边界情况：新插入结点再最后一个位置，需特殊处理</li></ul></li><li><p>删除（后删）</p><ul><li>注意删除结点的前驱结点、后继结点的指针修改</li><li>边界情况：如果被删除的结点是最后一个数据结点，需特殊处理</li></ul></li><li><p>遍历</p><ul><li>从一个给定结点开始，后向遍历、前向遍历的实现（循环的终止条件）</li><li>链表不具备随机存取特性，查找操作只能通过顺序遍历实现</li></ul></li></ul></li><li><p>循环单链表</p><ul><li>空表</li><li>非空表</li></ul></li><li><p>循环双链表</p><ul><li>空表</li><li>非空表</li></ul></li><li><p>代码问题</p><ul><li>如何判空</li><li>如何判断结点 p 是否是表尾/表头结点</li><li>如何在表头、表中、表尾插入/删除一个结点</li></ul></li></ul><h3 id="链式栈与链式队列">5. 链式栈与链式队列</h3><ul><li><p>链式栈</p><ul><li><p>用链式存储方式实现的栈</p></li><li><p>两种实现方式</p><ul><li>带头结点</li><li>不带头结点（推荐）</li></ul></li><li><p>重要基本操作</p><ul><li>创（初始化）</li><li>增（进栈）</li><li>删（出栈）</li><li>查（获取栈顶元素）</li><li>如何判空、判满？</li></ul></li></ul></li><li><p>链式队列</p><ul><li><p>用链式存储实现队列</p><ul><li>带头结点</li><li>不带头结点</li></ul></li><li><p>基本操作</p><ul><li><p>创（初始化）</p></li><li><p>增（入队）</p><ul><li>注意第一个元素入队</li></ul></li><li><p>删（出队）</p><ul><li>注意最后一个元素出队</li></ul></li><li><p>查（获取队头元素）</p></li><li><p>判空</p></li><li><p>判满？不存在的</p></li></ul></li></ul></li></ul><h2 id="第四章-字符串数据与特殊矩阵">第四章 字符串、数据与特殊矩阵</h2><h3 id="字符串及模式匹配">1. 字符串及模式匹配</h3><ul><li><p>串</p><ul><li><p>定义</p><ul><li>串，即字符串（String）是由零个或多个字符组成的有限序列</li><li>术语：串长、空串、空格串、子串、主串、字符在主串中的位置、子串在主串中的位置</li></ul></li><li><p>串 vs 线性表</p><ul><li>串的数据对象限定为字符集</li><li>串的基本操作大多以”子串“为操作对象</li></ul></li><li><p>基本操作</p><ul><li>Index(S,T)，定位操作，找到串 T 在主串 S 中的位置</li><li>StrCompare(S,T)：比较操作。若 S&gt;T，则返回值&gt;0；若 S=T，则返回值=0；若 S&lt;T，则返回值&lt;0。</li><li>其他…</li></ul></li><li><p>字符集编码</p><ul><li>每个字符在计算机中对应一个二进制数，比较字符的大小其实就是比较二进制数的大小。</li></ul></li></ul></li><li><p>串的存储结构</p><ul><li><p>顺序存储</p><ul><li><p>静态数组</p></li><li><p>动态数组</p><ul><li>malloc、free</li></ul></li></ul></li><li><p>链式存储</p><ul><li>可让每个结点存多个字符，没有字符的位置用'#'或'\0'补足</li></ul></li><li><p>王道教材采用——静态数组</p></li><li><p>基本操作的实现</p><ul><li>求子串：bool SubString(SString &amp;Sub,SString S,int pos,int len)</li><li>串的比较：int StrCompare(SString S,SString T)</li><li>求串在主串中的位置：int Index(SString S,SString T)</li></ul></li></ul></li><li><p>朴素模式匹配算法</p><ul><li><p>算法思想</p><ul><li>主串长度 n，模式串长度 m</li><li>将主串中所有长度为 m 的子串与模式串对比</li><li>找到第一个与模式串匹配的子串，并返回子串起始位置</li><li>若所有子串都不匹配，则返回 0</li></ul></li><li><p>最坏时间复杂度=O(mn)</p></li></ul></li><li><p>KMP 算法 <img src="3fc445370720dba5b2e3147eb0bab4bce8b97e15c79abf6f143cc39b8fc3152d.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li><p>精髓：利用好已经匹配过的模式串的信息</p></li><li><p>最坏时间复杂度：O(m+n) 其中，求 next 数组时间复杂度 O(m) 模式匹配过程最坏时间复杂度 O(n)</p></li><li><p>求 next 数组 <img src="0b9f8dc717d5c34a928d3754222619e94900d8ab9c19639a48efa92e02b321e0.png" srcset="/img/loading.gif" lazyload alt="image"></p></li><li><p>next 数组优化——nextval 数组</p><ul><li>当前元素和 next[j]的元素比较 一样就是用 下标为 next[j]元素的 nextval[j]的值 不一样就用当前的 next[j]的值</li></ul></li></ul></li></ul><h3 id="特殊矩阵的压缩存储">2. 特殊矩阵的压缩存储</h3><ul><li><p>对称矩阵</p><ul><li>特点：对方阵中的任意一个元素，有 ai,j=aj,i</li><li>压缩：只存储主对角线和下三角区（或主对角线+上三角区）</li></ul></li><li><p>三角矩阵</p><ul><li>特点：上三角区全为常量（下三角矩阵）；或下三角区全为常量（上三角矩阵）</li><li>压缩：按行优先/列优先规则依次存储非常量区域，并在最后一个位置存放常量 c</li></ul></li><li><p>三对角矩阵（带状矩阵）</p><ul><li>特点：当|i-j|&gt;1 时，有 ai,j=0(1&lt;=i,j&lt;=n)</li><li>压缩：按行优先/列优先规则依次存储带状区域</li></ul></li></ul><h3 id="稀疏矩阵">3. 稀疏矩阵</h3><ul><li><p>非零元素个数远小于零元素个数</p></li><li><p>压缩：只存储非零元素</p><ul><li>顺序存储：顺序存储三元组，&lt;行，列，值&gt;</li><li>链式存储：十字链表法</li></ul></li></ul><h2 id="第五章-递归">第五章 递归</h2><h3 id="递归的基本概念与递归程序设计">1. 递归的基本概念与递归程序设计</h3><ul><li>递归是一种编程技术，它允许函数调用自身来解决问题。这种方法的基本思想是将一个大问题分解为更小的子问题，然后使用相同的解决方案来解决这些子问题。</li><li>递归函数通常有两个主要部分：基本情况（base case）和递归情况（recursive case）。基本情况是函数处理的最小问题，可以直接解决，不需要进一步的递归调用。递归情况则是将问题分解为更小的子问题，并对这些子问题进行递归调用。</li><li>例如，计算阶乘的函数就是一个典型的递归函数。阶乘函数的基本情况是 0! = 1，递归情况是 n! = n * (n-1)!。在这个例子中，我们可以看到，递归情况将问题（计算 n 的阶乘）分解为一个更小的问题（计算(n-1)的阶乘），并对这个更小的问题进行递归调用。</li></ul><h3 id="递归程序设计执行过程的分析">2. 递归程序设计执行过程的分析</h3><ul><li>理解递归程序的执行过程需要理解递归调用栈。每次函数调用自身时，系统都会在内存中为该函数调用创建一个新的环境。这个环境包含了函数的参数和局部变量。当函数返回时，它的环境被弹出调用栈，并且控制权返回到调用它的函数。</li></ul><p>例如，我们来看一下计算阶乘的递归函数的执行过程。假设我们要计算 5!，那么函数调用栈将如下所示：</p><p>首先，我们调用 factorial(5)。因为 5 不等于 0，所以我们进入递归情况，计算 5 _ factorial(4)。 然后，我们调用 factorial(4)。因为 4 不等于 0，所以我们进入递归情况，计算 4 _ factorial(3)。 我们继续这个过程，直到我们调用 factorial(0)。因为 0 等于 0，所以我们进入基本情况，返回 1。 然后，每个递归调用开始返回。factorial(1)返回 1 _ 1 = 1，factorial(2)返回 2 _ 1 = 2，factorial(3)返回 3 _ 2 = 6，依此类推。 最后，factorial(5)返回 5 _ 24 = 120。 通过这个过程，我们可以看到递归是如何通过将问题分解为更小的子问题，并对这些子问题进行递归调用来解决问题的。同时，我们也可以看到递归调用栈是如何在内存中创建和管理的。</p><h3 id="递归程序到非递归程序的转换">3. 递归程序到非递归程序的转换</h3><ul><li>递归到非递归的转换是一种常见的编程技术，主要用于优化程序的时间和空间效率。虽然递归在解决某些问题时非常直观和优雅，但是它也可能导致额外的时间和空间开销，特别是在处理大规模数据或深度递归时。因此，有时我们需要将递归程序转换为非递归程序。</li></ul><p>转换过程通常涉及到使用循环（如 while 或 for 循环）和数据结构（如堆栈）来显式地模拟递归调用栈。这是因为在递归中，函数调用自身时，会在内存中创建一个新的环境（包含函数的参数和局部变量），这个环境被称为一个栈帧。所有的栈帧都被存储在一个叫做调用栈的数据结构中。当函数返回时，它的栈帧被从调用栈中弹出，并且控制权返回到调用它的函数。</p><p>例如，我们可以将计算阶乘的递归函数转换为非递归函数。在递归版本中，我们通过连续地调用函数自身并乘以当前的数字来计算阶乘。而在非递归版本中，我们可以使用一个 for 循环来迭代从 1 到 n 的所有数字，并将它们相乘以计算阶乘。</p><p>以下是一个使用 C 语言编写的非递归阶乘函数的示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>        result *= i;<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> number = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Factorial of %d is %llu\n"</span>, number, factorial(number));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>需要注意的是，并不是所有的递归问题都能轻易地转换为非递归形式。有些问题（如树的遍历、图的搜索等）的非递归解决方案可能会更复杂，更难以理解和实现。此外，有些问题可能需要使用特定的数据结构（如队列或堆栈）来辅助非递归解决方案。</p><p>希望这个解释对你有所帮助！</p><h2 id="第六章-树">第六章 树</h2><h3 id="树的概念">1. 树的概念</h3><ul><li><p>基本概念</p><ul><li>结点、边、根节点、叶子结点、分支节点、子树</li></ul></li><li><p>基本术语</p><ul><li><p>结点之间的关系</p><ul><li>父节点（双亲结点）、孩子结点</li><li>祖先结点、子孙结点</li><li>兄弟结点、堂兄弟结点</li><li>结点之间的路径——只能从上往下</li><li>路径长度——路径上经过多少条边</li></ul></li><li><p>结点、树的属性</p><ul><li><p>结点的层次（深度）、结点的高度</p></li><li><p>树的深度（高度）</p></li><li><p>🚩 结点的度</p><ul><li>结点的分支数</li></ul></li><li><p>🚩 树的度</p><ul><li>树中各结点的度的最大值</li></ul></li></ul></li><li><p>有序树 VS 无序树</p><ul><li>逻辑上看，各子树是否有序，位置是否可互换</li></ul></li><li><p>森林</p><ul><li>由 m(m&gt;=0)个互不相交的树组成森林</li></ul></li></ul></li><li><p>常考性质</p><ul><li><p>考点 1</p><ul><li>结点数=总度数+1</li></ul></li><li><p>考点 2</p><ul><li><p>🚩 度为 m 的树</p><ul><li>至少有一个结点度 = m</li><li>一定是非空树</li></ul></li><li><p>🚩m 叉树</p><ul><li>允许所有结点的度都&lt;m</li><li>可以是空树</li></ul></li></ul></li><li><p>考点 3</p><ul><li>度为 m 的树第 i 层至多有几个结点?</li></ul></li><li><p>考点 4</p><ul><li>高度为 h 的 m 叉树至多有几个结点?</li></ul></li><li><p>考点 5</p><ul><li>🚩 高度为 h 的 m 叉树至少有多少个结点?</li><li>🚩 高度为 h、度为 m 的树至少有多少个结点?</li></ul></li><li><p>考点 6</p><ul><li>具有 n 个结点的 m 叉树的最小高度为?</li></ul></li></ul></li></ul><h3 id="树的存储结构">2. 树的存储结构</h3><ul><li><p>双亲表示法</p><ul><li>顺序存储结点数据，结点中保存父节点在数组中的下标</li><li>优点：找父节点方便；缺点：找孩子不方便</li></ul></li><li><p>孩子表示法</p><ul><li>顺序存储结点数据，结点中保存孩子链表头指针（顺序+链式存储）</li><li>优点：找孩子方便；缺点：找父节点不方便</li></ul></li><li><p>孩子兄弟表示法</p><ul><li>用二叉链表存储树——左孩子右兄弟</li><li>孩子兄弟表示法存储的树，从存储视角来看形态上和二叉树类似</li><li>考点：树与二叉树的相互转换。本质就是用孩子兄弟表示法存储树</li></ul></li></ul><h3 id="树的遍历">3. 树的遍历</h3><ul><li><p>树的遍历</p><ul><li>先根遍历 <img src="dc5b8d8726a6401fa44f1ecc38a76eeef64294127337049ccb21eb75a51ebfc1.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>后根遍历 <img src="34f6a5775cb461bc8bbb559f7d7b3d1e19b5eebf8ce49e213057f68bd9a722c6.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>层序遍历 <img src="f7a05267c53c5c5a20ddc7b9c456939cc41a72d46b5dd8b2755dc09d34f29709.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li><li><p>森林的遍历</p><ul><li>先序遍历 <img src="b00619f7a7b945502524b82173724a5cf72ca2cac2153b461b44276fcab08ee0.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>中序遍历 <img src="15f8aca1c35e14a1290ead386b6874d112e4e5c00aa0290054871272f2ae653b.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li></ul><h2 id="第七章-二叉树">第七章 二叉树</h2><h3 id="二叉树的基本概念">1. 二叉树的基本概念</h3><ul><li><p>基本概念</p><ul><li>可为空二叉树</li><li>任意结点的度&lt;2</li><li>是有序树，左子树、右子树不可颠倒</li><li>思考：二叉树 V.S 度为 2 的有序树</li></ul></li><li><p>特殊二叉树</p><ul><li><p>满二叉树</p><ul><li>高度为 h，含有 2^h- 1 个结点的二叉树</li></ul></li><li><p>完全二叉树</p><ul><li>在满二叉树的基础上可去掉若干个编号更大的结点</li></ul></li><li><p>二叉排序树</p><ul><li>左子树关键字&lt;根节点关键字&lt;右子树关键字</li></ul></li><li><p>平衡二叉树</p><ul><li>左右子树深度差不超过 1</li></ul></li></ul></li><li><p>常见考点</p><ul><li><p>具有 n 个(n&gt;0) 结点的完全二叉树的高度 h 为 <img src="d87c46606aae3c356f8e3c700f6b0b0bb493c22a131c927f6f5c783c84d4f4fe.png" srcset="/img/loading.gif" lazyload alt="image"></p></li><li><p>高为 h 的满二叉树共有 2^h-1 个结点 高为 h-1 的满二叉树共有 2^(h-1)-1 个结点</p></li><li><p>对完全二叉树，可以由结点数 n 推出度为 0、1 和 2 的结点个数为 <img src="580a1bc05381de4479b9567079e0af008519f1b84d1e9744f6d62b8700a4f1cd.png" srcset="/img/loading.gif" lazyload alt="image"></p></li><li><p>完全二叉树最多只有一个度为 1 的结点，即 <img src="5509c85f9f66f7659a01d0d78b51a6e053a1a0091187c6d782682ad8fbca51ff.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li>若完全二叉树有 2k 个（偶数）个结点，则必有 <img src="bfdd5b3f75b792cba75544406ac7c34405766f840e873c683197aafb1e2dbeb2.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>若完全二叉树有 2k-1 个（奇数）个结点，则必有 <img src="f7875ec4c4604df9fe7a8ef340b29953b476ff5386ffe67bf98b4011c27eb9e6.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li></ul></li></ul><h3 id="二叉树的存储结构">2. 二叉树的存储结构</h3><ul><li><p>顺序存储：存放先序遍历序列在数组之中</p><ul><li><p>几个重要常考的基本操作</p><ul><li>i 的左孩子——2i</li><li>i 的右孩子——2i+1</li><li>i 的父节点——[I/2]</li><li>i 所在的层次—— <img src="c96ae0d31ad47abad36ec269e57c73f305cf90db65e184b0c9f16f4cc949e1dd.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li><li><p>若完全二叉树中共有 n 个结点，则</p><ul><li>判断 i 是否有左孩子?</li><li>判断 i 是否有右孩子?</li><li>判断 i 是否是叶子/分支结点?</li></ul></li></ul></li><li><p>链式存储：一个数据变量+两个指针</p><ul><li>n 个结点的二叉链表共有 n+1 个空链域</li></ul></li></ul><h3 id="二叉树的遍历递归与非递归">3. 二叉树的遍历（递归与非递归）</h3><ul><li><p>三种方法</p><ul><li><p>先序遍历</p><ul><li>根、左、右</li></ul></li><li><p>中序遍历</p><ul><li>左、根、右</li></ul></li><li><p>后序遍历</p><ul><li>左、右、根</li></ul></li></ul></li><li><p>遍历算数表达式树</p><ul><li>先序遍历得前缀表达式</li><li>中序遍历得中缀表达式（没有括号）</li><li>后序遍历得后缀表达式</li></ul></li><li><p>考点：求遍历序列</p><ul><li><p>分支结点逐层展开法...</p></li><li><p>从你的全世界路过法</p><ul><li>先序一一第一次路过时访问</li><li>中序——第二次路过时访问</li><li>后序——第三次路过时访问</li></ul></li></ul></li><li><p>层序遍历</p><ul><li>① 初始化一个辅助队列</li><li>② 根结点入队</li><li>③ 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</li></ul></li><li><p>由二叉树的遍历序列构造二叉树 <img src="f025acaa886a38d66fc57a807665c66bb9afa369863125907d8c4c2273728f0a.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li>前序+中序遍历序列</li><li>后序+中序遍历序列</li><li>层序+中序遍历序列</li></ul></li></ul><h3 id="穿线二叉树的基本概念与构造">4. 穿线二叉树的基本概念与构造</h3><ul><li><p>作用：方便从一个指定结点出发，找到其前驱、后继；方便遍历</p></li><li><p>存储结构</p><ul><li>在普通二叉树结点的基础上，增加两个标志位 ltag 和 rtag</li><li>ltag=1 时，表示 lchild 指向前驱；ltag==0 时，表示 lchild 指向左孩子</li><li>rtag==1 时，表示 rchild 指向后继；rtag==0 时，表示 rchild 指向右孩子</li></ul></li><li><p>三种线索二叉树</p><ul><li><p>中序线索二叉树</p><ul><li>以中序遍历序列为依据进行”线索化“</li></ul></li><li><p>先序线索二叉树</p><ul><li>以先序遍历序列为依据进行”线索化“</li></ul></li><li><p>后序线索二叉树</p><ul><li>以后序遍历序列为依据进行”线索化“</li></ul></li></ul></li><li><p>几个概念</p><ul><li><p>线索</p><ul><li>指向前驱/后继的指针称为线索</li></ul></li><li><p>中序前驱/中序后继；先序前驱/先序后继；后序前驱/后序后继</p></li></ul></li><li><p>⚠ 手算画出线索二叉树</p><ul><li>① 确定线索二叉树类型-中序、先序、or 后序？</li><li>② 按照对应遍历规则，确定各个结点的访问顺序，并写上编号</li><li>③ 将 n+1 个空链域连上前驱、后继</li></ul></li><li><p>二叉树线索化</p><ul><li><p>中序线索化</p><ul><li>得到中序线索二叉树</li></ul></li><li><p>先序线索化</p><ul><li>得到先序线索二叉树</li></ul></li><li><p>后序线索化</p><ul><li>得到后序线索二叉树</li></ul></li><li><p>核心</p><ul><li>中序/先序/后序遍历算法的改造，当访问一个结点时，连接该结点与前驱结点的线索信息</li><li>用一个指针 pre 记录当前访问结点的前驱结点</li></ul></li><li><p>易错点</p><ul><li>最后一个结点的 rchild 、rtag 的处理</li><li>先序线索化中，注意处理爱滴魔力转圈圈问题，当 ltag==0 时，才能对左子树先序线索化</li></ul></li></ul></li><li><p>高频考点</p><ul><li><p>线索化</p><ul><li>⚠ 手算</li><li>代码</li></ul></li><li><p>⚠ 找前驱、找后继</p></li></ul></li></ul><h3 id="树森林和二叉树的转换">5. 树、森林和二叉树的转换</h3><ul><li><p>森林与二叉树的转换 <img src="245eaa21a284ec51189935e18f99a3995bf061fafdb392978bbdc11e0b3fe390.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li>本质：用二叉链表存储森林——左孩子右兄弟</li><li>森林中各个树的根节点之间视为兄弟关系</li></ul></li></ul><h2 id="第八章-图">第八章 图</h2><h3 id="图的基本概念">1. 图的基本概念</h3><ul><li><p>定义：G=(V,E)，顶点集 V，边集 E</p></li><li><p>无向图 （无向边/边）、有向图 （有向边/弧）</p></li><li><p>顶点的度、出度、入度 （无向图? 有向图？）</p></li><li><p>边的权、带权图/网</p></li><li><p>点到点的关系</p><ul><li>路径、回路、简单路径、简单回路</li><li>路径长度</li><li>点到点的距离（最短路径）</li><li>无向图顶点的连通性、连通图</li><li>有向图顶点的强连通性、强连通图</li></ul></li><li><p>图的局部</p><ul><li>子图</li><li>连通分量一一极大连通子图</li><li>强连通分量——极大强连通子图</li><li>连通无向图的生成树——包含全部顶点的极小连通子图非</li><li>连通无向图的生成森林一一各连通分量的生成树</li></ul></li><li><p>几种特殊形态的图</p><ul><li>完全图</li><li>稠密图、稀疏图</li><li>树、森林、有向树</li></ul></li><li><p>基本操作 <img src="5de9e12ee83ba2bcf42c033add5c043022001b9344ab05541fb4c4b44a395f7a.png" srcset="/img/loading.gif" lazyload alt="image"></p></li></ul><h3 id="图的存储结构邻接矩阵法邻接表法">2. 图的存储结构（邻接矩阵法、邻接表法）</h3><figure><img src="180f6e97774394caf48c081ea93e84681f83477598301b8f61e0fd51a29d4c7f.png" srcset="/img/loading.gif" lazyload alt="image"><figcaption aria-hidden="true">image</figcaption></figure><h3 id="图的遍历">3. 图的遍历</h3><ul><li><p>BFS</p><ul><li><p>类似于树的层序遍历（广度优先遍历）</p></li><li><p>算法要点</p><ul><li>需要一个辅助队列</li><li>如何从一个结点找到与之邻接的其他顶点</li><li>visited 数组防止重复访问</li><li>如何处理非连通图</li></ul></li><li><p>复杂度</p><ul><li><p>空间复杂度:O(IVI)——辅助队列</p></li><li><p>时间复杂度</p><ul><li>访问结点的时间+访问所有边的时间</li><li>邻接矩阵：O(IVI^2)</li><li>邻接表：O(|V|+|E|)</li></ul></li></ul></li></ul></li><li><p>DFS</p><ul><li><p>算法要点</p><ul><li>递归地深入探索未被访问过的邻接点（类似于树的先根遍历的实现）</li><li>如何从一个结点找到与之邻接的其他顶点</li><li>visited 数组防止重复访问</li><li>如何处理非连通图</li></ul></li><li><p>复杂度分析</p><ul><li><p>空间复杂度: O(IV|)——来自递归工作栈</p></li><li><p>时间复杂度</p><ul><li>访问结点的时间+访问所有边的时间</li><li>邻接矩阵：O(IVI^2)</li><li>邻接表：O(IV|+|E|)</li></ul></li></ul></li><li><p>图的遍历和图的连通性</p><ul><li><p>无向图</p><ul><li>DFS/BFS 函数调用次数=连通分量数</li></ul></li><li><p>有向图</p><ul><li>若从起始顶点到其他顶点都有路径，则只需调用 1 次 DFS/BFS 函数</li><li>对于强连通图，从任一顶点出发都只需调用 1 次 DFS/BFS 函数</li></ul></li></ul></li></ul></li></ul><h3 id="生成树与最小生成树">4. 生成树与最小生成树</h3><ul><li><p>广度优先生成树</p><ul><li>由广度优先遍历确定的树</li><li>邻接表存储的图表示方式不唯一，遍历序列、生成树也不唯一</li><li>遍历非连通图可得广度优先生成森林</li></ul></li><li><p>深度优先生成树</p><ul><li>由深度优先遍历确定的树</li><li>邻接表存储的图表示方式不唯一，深度优先遍历序列、生成树也不唯一</li><li>深度优先遍历非连通图可得深度优先生成森林</li></ul></li><li><p>最小生成树 <img src="926de10ec595f3b744105d39f490f09ba720d6269278b81433084f01fba08d77.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li><p>最小生成树的概念</p><ul><li>边的权值之和最小的生成树</li></ul></li><li><p>Prim 算法</p><ul><li>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</li></ul></li><li><p>Kruskal 算法</p><ul><li>每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)</li><li>直到所有结点都连通</li></ul></li></ul></li></ul><h3 id="最短路径">5. 最短路径</h3><ul><li><p>单源最短路径</p><ul><li>BFS 算法(无权图) <img src="eeb62ee5422e9a46941665e872cb2f11d539c319f496d9edaf6830eda2c3a404.png" srcset="/img/loading.gif" lazyload alt="image"></li><li>Dijkstra 算法(带权图、无权图)——不适用于有负权值的带权图 <img src="2ce80a67e4a79719d250723fad942d01e664f11f31c121359f106e3e561b9c64.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li><li><p>各顶点间的最短路径</p><ul><li>Floyd 算法 (带权图、无权图)——不能解决带有“负权回路”的图（有负权值的边组成回路），这种图困难没有最短路径 <img src="c54b7d231c4312cc097b36ac1189b483336b632818f3c122e4a51981e79575a1.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li></ul><h3 id="拓扑排序">6. 拓扑排序</h3><ul><li><p>AOV 网</p><ul><li>顶点代表活动，有向边&lt;Vi,vj&gt;表示活动 Vi 必须先于 Vj 进行</li><li>AOV 网一定是 DAG 图，不能有环</li></ul></li><li><p>拓扑排序</p><ul><li>① 从 AOV 网中选择一个没有前驱（入度为 0）的顶点并输出</li><li>② 从网中删除该顶点和所有以它为起点的有向边</li><li>③ 重复 ① 和 ② 直到当前的 AOV 网为空</li></ul></li><li><p>逆拓扑排序</p><ul><li>① 从 AOV 网中选择一个没有后继（出度为 0）的顶点并输出</li><li>② 从网中删除该顶点和所有以它为终点的有向边</li><li>③ 重复 ① 和 ② 直到当前的 AOV 网为空</li></ul></li><li><p>另一种实现方式：用 DFS 实现拓扑排序/逆拓扑排序</p></li><li><p>性质</p><ul><li>拓扑排序、逆拓扑排序序列可能不唯一</li><li>若图中有环，则不存在拓扑排序序列/逆拓扑排序序列</li></ul></li></ul><h3 id="关键路径">7. 关键路径</h3><ul><li><p>AOE 网</p><ul><li><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销</p></li><li><p>相关概念</p><ul><li>在 AOE 网中仅有一个入度为 0 的顶点，称为开始顶点（源点），它表示整个工程的开始:</li><li>也仅有一个出度为 0 的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</li></ul></li></ul></li><li><p>求解方法</p><ul><li><p>① 求所有事件的最早发生时间 ve()</p></li><li><p>② 求所有事件的最迟发生时间 vl()</p></li><li><p>③ 求所有活动的最早发生时间 e()</p></li><li><p>④ 求所有活动的最迟发生时间 I()</p></li><li><p>⑤ 求所有活动的时间余量 d()</p><ul><li>d(i)=0 的活动就是关键活动由关键活动可得关键路径</li></ul></li></ul></li><li><p>特性</p><ul><li>若关键活动耗时增加，则整个工程的工期将增长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ul></li></ul><h3 id="有向无环图描述表达式">有向无环图描述表达式</h3><ul><li>Step 1:把各个操作数不重复地排成一排</li><li>step 2:标出各个运算符的生效顺序 (先后顺序有点出入无所谓)</li><li>Step 3:按顺序加入运算符，注意“分层</li><li>Step 4:从底向上逐层检查同层的运算符是否可以合体</li></ul><h2 id="第九章-检索">第九章 检索</h2><h3 id="检索的基本概念">1. 检索的基本概念</h3><ul><li><p>基本概念</p><ul><li><p>查找</p><ul><li>找到符合条件的数据元素（记录）</li></ul></li><li><p>查找表</p><ul><li><p>由同一类型的数据元素（记录）组成</p></li><li><p>静态查找表</p><ul><li>只需要查找操作</li></ul></li><li><p>动态查找表</p><ul><li>除了查找，还需要增/删数据元素</li></ul></li></ul></li><li><p>关键字</p><ul><li>唯一标识数据元素的数据项</li></ul></li></ul></li><li><p>查找算法的效率评价</p><ul><li>平均查找长度 ASL</li><li>通常考虑查找成功、查找失败两种情况下的 ASL</li></ul></li></ul><h3 id="线性表的检索">2. 线性表的检索</h3><ul><li><p>顺序表的查找</p><ul><li><p>按位查找</p><ul><li><p>GetElem(L,i)</p><ul><li>获取表 L 中第 i 个位置的元素的值</li><li>用数组下标即可得到第 i 个元素 L.data[i-1]</li></ul></li><li><p>时间复杂度</p><ul><li>最好/最坏/平均时间复杂度都是 O(1)</li></ul></li></ul></li><li><p>按值查找</p><ul><li><p>LocateElem(L,e)</p><ul><li>在顺序表 L 中查找第一个元素值等于 e 的元素，并返回其位序</li><li>从第一个元素开始依次往后检索</li></ul></li><li><p>时间复杂度</p><ul><li>最好 O(1)：目标元素再第一个位置</li><li>最坏 O(n)：目标元素再最后一个位置</li><li>平均 O(n)：目标元素再每个位置的概率相同</li></ul></li></ul></li></ul></li><li><p>单链表的查找</p><ul><li><p>按位查找</p><ul><li>注意与“顺序表”对比</li><li>单链表不具备“随机访问”的特性，只能依次扫描</li></ul></li><li><p>按值查找</p></li><li><p>key</p><ul><li>三种基本操作的时间复杂度都是 O(n)</li><li>如何写循环扫描各个结点的代码逻辑</li><li>注意边界条件的处理</li></ul></li></ul></li></ul><h3 id="二叉排序树">3. 二叉排序树</h3><ul><li><p>二叉排序树的定义</p><ul><li>⚠ 左子树结点值 &lt;根结点值&lt;右子树结点值</li><li>默认不允许两个结点的关键字相同</li></ul></li><li><p>查找操作</p><ul><li>从根节点开始，目标值更小往左找，目标值更大往右找</li></ul></li><li><p>插入操作</p><ul><li>找到应该插入的位置(一定是叶子结点)，一定要注意修改其父节点指针</li></ul></li><li><p>⚠ 删除操作</p><ul><li><p>① 被删结点为叶子，直接删除</p></li><li><p>② 被删结点只有左或只有右子树，用其子树顶替其位置</p></li><li><p>③ 被删结点有左、右子树</p><ul><li>可用其后继结点顶替，再删除后继结点</li><li>或用其前驱结点顶替，再删除前驱结点</li><li>前驱:左子树中最右下的结点</li><li>后继:右子树中最左下的结点</li></ul></li></ul></li><li><p>查找效率分析</p><ul><li><p>取决于树的高度，最好 o(log n)，最坏 O(n)</p></li><li><p>⚠ 平均查找长度的计算</p><ul><li>查找成功的情况</li><li>查找失败的情况（需补充失败结点）</li></ul></li></ul></li></ul><h3 id="平衡二叉排序树">4. 平衡二叉排序树</h3><ul><li><p>定义</p><ul><li>树上任一结点的左子树和右子树的高度之差不超过 1</li><li>结点的平衡因子=左子树高-右子树高</li></ul></li><li><p>插入操作</p><ul><li>和二叉排序树一样，找合适的位置插入</li><li>新插入的结点可能导致其祖先们平衡因子改变，导致失衡</li></ul></li><li><p>删除操作</p><ul><li><p>① 删除结点（方法同二叉排序树）</p><ul><li>若删除的结点是叶子，直接删。</li><li>若删除的结点只有一个子树，用子树顶替删除位置。</li><li>若删除的结点有两棵子树，用前驱（或后继）结点顶替，并转换为对前驱（或后）结点的删除。</li></ul></li><li><p>② 一路向北找到最小不平衡子树，找不到就完结撒花</p></li><li><p>③ 找最小不平衡子树下，“个头”最高的儿子、孙子</p></li><li><p>④ 根据孙子的位置，调整平衡 (LL/RR/LR/RL)</p><ul><li>孙子在 LL: 儿子右单旋</li><li>孙子在 RR: 儿子左单旋</li><li>孙子在 LR:孙子先左旋，再右旋</li><li>孙子在 RL:孙子先右旋，再左旋</li></ul></li><li><p>⑤ 如果不平衡向上传导，继续 ②</p><ul><li>对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</li></ul></li><li><p>时间复杂度 <img src="a6c2d85bace4dd7c58dad19f89760796d5b2d4674601aa859ed49bc84fa33811.png" srcset="/img/loading.gif" lazyload alt="image"></p></li></ul></li><li><p>⚠ 调整“不平衡”</p><ul><li><p>找到最小不平衡子树进行调整，记最小不平衡子树的根为 A</p></li><li><p>LL</p><ul><li>在 A 的左孩子的左子树插入导致 A 不平衡，将 A 的左孩子右上旋</li></ul></li><li><p>RR</p><ul><li>在 A 的右孩子的右子树插入导致 A 不平衡，将 A 的右孩子左上旋</li></ul></li><li><p>LR</p><ul><li>在 A 的左孩子的右子树插入导致 A 不平衡，将 A 的左孩子的右孩子 先左上旋再右上旋</li></ul></li><li><p>RL</p><ul><li>在 A 的右孩子的左子树插入导致 A 不平衡，将 A 的右孩子的左孩子 先右上旋再左上旋</li></ul></li></ul></li><li><p>查找效率分析</p><ul><li>考点：高为 h 的平衡二叉树最少有几个结点一递推求解</li><li>平衡二叉树最大深度为 O(log n)，平均查找长度/查找的时间复杂度为 O(log n)</li></ul></li></ul><h3 id="哈夫曼树">5. 哈夫曼树</h3><ul><li><p>概念</p><ul><li>结点的权：某种特定含义的数值</li><li>结点的带权路径长度 =根到结点路径长度*结点的权值</li><li>树的带权路径长度(WPL)= 树中所有叶子结点的带权路径长度之和</li><li>哈夫曼树(最优二叉树)：在含有给定的 n 个带权叶结点的二叉树中，WPL 最小的二叉树</li></ul></li><li><p>构造哈夫曼树</p><ul><li>每次选两个根节点权值最小的树合并，并将二者权值之和作为新的根节点的权值</li><li>哈夫曼树不唯一，但 WPL 必然都是最小值</li></ul></li><li><p>哈夫曼编码</p><ul><li>将字符频次作为字符结点权值，构造哈夫曼树，即可得哈夫曼编码，可用于数据压缩</li><li>前缀编码——没有一个编码是另一个编码的前缀</li><li>固定长度编码——每个字符用相等长度的二进制位表示</li><li>可变长度编码——允许对不同字符用不等长的二进制位表示</li></ul></li></ul><h3 id="b-树">6. B 树</h3><ul><li><p>概念 <img src="404b653bb1bd189baa31d2f895852a1c1f30415eb37e13f81a99c6d69cf1cc40.png" srcset="/img/loading.gif" lazyload alt="image"></p><ul><li>注意事项 <img src="dd4808e2458876718d2e94c4e1a6957312d9ade27dd5f2e8702d228e11d78f95.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li><li><p>特性 <img src="f2a5a29ab31152461fffc83462bf5e4100033f7932925f5883a4fe7f06eae4cf.png" srcset="/img/loading.gif" lazyload alt="image"></p></li><li><p>插入</p><ul><li>通过“查找”确定插入位置(一定是在终端结点)</li><li>若插入后结点关键字个数未超过上限，则无需做其他处理</li><li>若插入后关键字个数超过上限，则需要将当前结点的中间元素放到父节点中，当前结点分裂为两个部分;该操作会导致父节点关键字个数+1，若父节点关键字个数也超过了上限，则需要再向上分裂;根节点的分裂会导致 B 树高度+1。</li></ul></li><li><p>删除</p><ul><li><p>非终端结点关键字</p><ul><li>用其直接前驱或直接后继替代其位置，转化为对“终端结点”的删除</li><li>直接前驱：当前关键字左边指针所指子树中“最右下”的元素</li><li>直接后继：当前关键字右边指针所指子树中“最左下”的元素</li></ul></li><li><p>终端结点关键字</p><ul><li><p>删除后结点关键字个数未低于下限，无需任何处理</p></li><li><p>低于下限</p><ul><li>右兄弟够借，则用当前结点的后继、后继的后继依次顶替空缺</li><li>左兄弟够借，则用当前结点的前驱、前驱的前驱依次顶替空缺</li><li>左(右)兄弟都不够借，则需要与父结点内的关键字、左(右)兄弟进行合并合并后导致父节点关键宇数量-1，可能需要继续合并。</li></ul></li></ul></li></ul></li></ul><h3 id="散列表的检索">7. 散列表的检索</h3><ul><li><p>概念</p><ul><li>散列表、散列函数 H(key)、同义词、冲突</li><li>装填因子 a=表中记录个数/散列表表长</li></ul></li><li><p>常见散列函数</p><ul><li><p>除留余数法</p><ul><li>H(key) = key % p，p 是不大于表长的质数</li></ul></li><li><p>直接定址法</p><ul><li>H(key) = key 或 H(key) = a*key + b</li></ul></li><li><p>数字分析法</p><ul><li>选取数码分布较为均匀的若干位作为散列地址</li></ul></li><li><p>平方取中法</p><ul><li>取关键字的平方值的中间几位作为散列地址</li></ul></li></ul></li><li><p>冲突的处理</p><ul><li><p>拉链法（链地址法）</p><ul><li>同义词串成一个链表</li></ul></li><li><p>开放定址法</p><ul><li><p>线性探测法</p><ul><li>di = 0, 1, 2, 3, ..., m-1</li></ul></li><li><p>平方探测法</p><ul><li>di = 0<sup>2,12,-1</sup>2, 2^2, -2^2 ...</li></ul></li><li><p>伪随机序列法</p><ul><li>di = 一个伪随机序列</li></ul></li></ul></li><li><p>再散列法</p><ul><li>准备多个散列函数，一个发生冲突了就用下一个</li></ul></li></ul></li><li><p>查找效率</p><ul><li>取决于 散列函数、处理冲突的方法、装填因子 a</li></ul></li></ul><h3 id="查找算法的分析及应用">8. 查找算法的分析及应用</h3><ul><li><p>顺序查找</p><ul><li><p>算法实现</p><ul><li>从头到 jio（或者从 jio 到头）挨个找</li><li>适用于顺序表、链表，表中元素有序无序都 OK</li><li>可在 0 号位置存“哨兵”，从尾部向头部挨个查找优点:循环时无需判断下标是否越界</li></ul></li><li><p>优化</p><ul><li><p>若表中元素有序</p><ul><li><p>当前关键字大于(或小于) 目标关键字时，查找失败</p></li><li><p>优点：查找失败时 ASL 更少</p></li><li><p>查找判定树</p><ul><li>成功结点的关键字对比次数=结点所在层数</li><li>失败结点的关键字对比次数=其父节点所在层数</li></ul></li></ul></li><li><p>若各个关键字被查概率不同</p><ul><li>可按被查概率降序排列</li><li>优点:查找成功时 ASL 更少</li></ul></li></ul></li><li><p>时间复杂度</p></li></ul></li><li><p>折半查找</p><ul><li><p>适用范围</p><ul><li>只适用于有序的顺序表</li></ul></li><li><p>算法思想</p><ul><li>在[low, high] 之间找目标关键字，每次检查 mid=(low+high)/2</li><li>根据 mid 所指元素与目标关键字的大小调整 low 或 high，不断缩小 low 和 high 的范围</li><li>若 low&gt;high 则查找失败</li></ul></li><li><p>判定树</p><ul><li><p>构造</p><ul><li>由 mid 所指元素将原有元素分割到左右子树中</li><li>Key：右子树结点数-左子树结点树=0 或 1</li><li>子主题 3</li></ul></li><li><p>特性</p><ul><li>折半查找的判定树是平衡的二叉排序树（左&lt;中&lt;右）</li><li>折半查找判定树，只有最下面一层是不满的</li><li>若查找表有 n 个关键字，则失败结点有 n+1 个</li><li>（不包含失败结点） <img src="895e5737ac16e172fc9f80d2d31facf3964c3f381a5d0d6f12a37f1df601479d.png" srcset="/img/loading.gif" lazyload alt="image"></li></ul></li></ul></li><li><p>时间复杂度</p></li></ul></li><li><p>分块查找</p><ul><li><p>又称“索引顺序查找”，数据分块存储，块内无序、块间有序</p></li><li><p>算法思想</p><ul><li>索引表中记录每个分块的最大关键字、分块的区间</li><li>先查索引表（顺序或折半）、再对分块内进行顺序查找</li></ul></li><li><p>ASL</p><ul><li><p>ASL=查索引表的平均查找长度+查分块的平均查找长度</p></li><li><p>设 n 个记录，均匀分为 b 块，每块 s 个记录</p><ul><li>顺序查找索引表</li><li>折半查找索引表</li></ul></li></ul></li><li><p>易错点</p><ul><li>对索引表进行折半查找时，若索引表中不包含目标关键字则折半查找最终停在 low&gt;high，要在 low 所指分块中查找</li></ul></li></ul></li></ul><h2 id="第十章-排序">第十章 排序</h2><h3 id="排序的基本概念">1. 排序的基本概念</h3><ul><li><p>将各元素按关键字递增/或递减顺序重新排列</p></li><li><p>评价指标</p><ul><li><p>稳定性</p><ul><li>关键字相同的元素经过排序后相对顺序是否会改变</li></ul></li><li><p>时间复杂度、空间复杂度</p></li></ul></li><li><p>分类</p><ul><li><p>内部排序</p><ul><li>数据都在内存中</li></ul></li><li><p>外部排序</p><ul><li>数据太多，无法全部放入内存</li></ul></li></ul></li></ul><h3 id="插入排序直接插入排序折半插入排序希尔排序">2. 插入排序（直接插入排序、折半插入排序、希尔排序）</h3><ul><li><p>插入排序</p><ul><li><p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p></li><li><p>直接插入排序</p><ul><li>顺序查找找到插入的位置，适用于顺序表、链表</li></ul></li><li><p>折半插入排序</p><ul><li>折半查找找到应插入的位置，仅适用于顺序表</li><li>注意：一直到 low&gt;high 时才停止折半查找。当 mid 所指元素等于当前元素时，应继续令 low=mid+1，以保证“稳定性”。最终应将当前元素插入到 low 所指位置 (即 high+1)</li></ul></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li><li><p>时间复杂度</p><ul><li><p>最好</p><ul><li>原本有序 O(n)</li></ul></li><li><p>最坏</p><ul><li>原本逆序 O(n^2)</li></ul></li><li><p>平均</p><ul><li>O(n^2)</li></ul></li></ul></li><li><p>稳定性</p><ul><li>稳定</li></ul></li></ul></li></ul></li><li><p>希尔排序</p><ul><li><p>先将待排序表分割成若干形如 L[i,i+ d,i+ 2d,...,i + kd]的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量 d，重复上述过程，直到 d=1 为止。</p></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li><li><p>时间复杂度</p><ul><li>未知，但优于直接插入排序</li></ul></li><li><p>稳定性</p><ul><li>不稳定</li></ul></li><li><p>适用性</p><ul><li>仅可用于顺序表</li></ul></li></ul></li><li><p>高频题型：给出增量序列，分析每一趟排序后的状态</p></li></ul></li></ul><h3 id="选择排序简单选择排序堆排序">3. 选择排序（简单选择排序、堆排序）</h3><ul><li><p>简单选择排序</p><ul><li><p>算法原理</p><ul><li>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</li><li>必须进行总共 n-1 趟处理</li></ul></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li><li><p>时间复杂度</p><ul><li>O(n^2)</li></ul></li><li><p>稳定性</p><ul><li>不稳定</li></ul></li><li><p>适用性</p><ul><li>顺序表、链表都可以</li></ul></li></ul></li></ul></li><li><p>堆排序</p><ul><li><p>堆</p><ul><li><p>顺序存储的“完全二叉树”</p><ul><li>结点 i 的左孩子是 2i；右孩子是 2i+1；父节点是 i/2</li><li>编号&lt;=n/2 的结点都是分支结点</li></ul></li><li><p>大根堆（根&gt;=左、右）；小根堆（根&lt;=左、右）</p></li></ul></li><li><p>算法思想 （以大根堆为例）</p><ul><li><p>建堆</p><ul><li>① 编号&lt;=n/2 的所有结点依次“下坠”调整（自底向上处理各分支节点）</li><li>② 调整规则：小元素逐层“下坠”（与关键字更大的孩子交换）</li></ul></li><li><p>排序</p><ul><li>③ 将堆顶元素加入有序子序列（堆顶元素与堆底元素交换）</li><li>④ 堆底元素换到堆顶后，需要进行“下坠”调整，恢复“大根堆”的特性</li><li>上述过程重复 n-1 趟</li></ul></li></ul></li><li><p>特性</p><ul><li><p>空间复杂度</p><ul><li>O(1)</li></ul></li><li><p>时间复杂度</p><ul><li>建堆 O(n)、排序 O(nlog n)；总的时间复杂度=O(nlog n)</li></ul></li><li><p>稳定性</p><ul><li>不稳定</li></ul></li><li><p>基于大根堆的堆排序得到“递增序列”，基于小根堆的堆排序得到“递减序列”</p></li></ul></li><li><p>插入</p><ul><li>新元素放到表尾（堆底）</li><li>根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止</li></ul></li><li><p>删除</p><ul><li>被删除元素用表尾（堆底）元素替代</li><li>根据大/小根堆的要求，替代元素不断“下坠”，直到无法继续下坠为止</li></ul></li><li><p>关键字对比次数</p><ul><li>每次“上升”调整只需对比关键字 1 次</li><li>每次“下坠”调整可能需要对比关键字 2 次，也可能只需对比 1 次</li></ul></li><li><p>基本次数</p><ul><li>i 的左孩子——2i i 的右孩子——2i+1 i 的父节点——[i/2]</li></ul></li></ul></li></ul><h3 id="交换排序冒泡排序快速排序">4. 交换排序（冒泡排序、快速排序）</h3><ul><li><p>冒泡排序</p><ul><li><p>算法原理</p><ul><li>从后往前(或从前往后) 两两比较相邻元素的值，若为逆序，则交换它们直到序列比较完。称这样过程为“一趟”冒泡排序。最多只需 n-1 趟排序</li><li>每一趟排序都可以使一个元素的移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比</li><li>如果某一趟排序过程中未发生“交换”，则算法可提前结束</li></ul></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>0(1)</li><li>稳定</li><li>顺序表、链表都可以</li></ul></li><li><p>时间复杂度</p><ul><li><p>最好 O(n)</p><ul><li>有序</li></ul></li><li><p>最差 O(n^2)</p><ul><li>逆序</li></ul></li><li><p>平均 O(n^2)</p></li></ul></li><li><p>稳定性</p><ul><li>稳定</li></ul></li><li><p>适用性</p><ul><li>顺序表、链表都可以</li></ul></li></ul></li></ul></li><li><p>快速排序</p><ul><li><p>算法表现主要取决于递归深度，若每次“划分”越均匀，则递归深度越低“划分”越不均匀，递归深度越深</p></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li><p>最好</p><ul><li>O(n)</li></ul></li><li><p>最坏</p><ul><li>O(log n)</li></ul></li></ul></li><li><p>时间复杂度</p><ul><li><p>最好</p><ul><li><p>O(n^2)</p><ul><li>每次划分很平均</li></ul></li></ul></li><li><p>最坏</p><ul><li><p>O(n log n)</p><ul><li>原本正序或逆序</li></ul></li></ul></li><li><p>平均</p><ul><li>O(n log n)</li></ul></li></ul></li><li><p>稳定性</p><ul><li>不稳定</li></ul></li></ul></li></ul></li></ul><h3 id="二路归并排序">5. 二路归并排序</h3><ul><li><p>Merge（归并）</p><ul><li>把两个或多个有序的子序列合并为一个</li><li>2 路归并——二合一</li><li>k 路归并——k 合一</li></ul></li><li><p>归并排序算法</p><ul><li>① 若 low&gt;high，则将序列分从中间 mid=(low+high)/2 分开</li><li>② 对左半部分[low,mid]递归地进行归并排序</li><li>③ 对右半部分[mid+1,high]递归地进行归并排序</li><li>④ 将左右两个有序子序列 Merge 为一个</li></ul></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>O(n)</li></ul></li><li><p>时间复杂度</p><ul><li>O(nlog n)</li></ul></li><li><p>稳定性</p><ul><li>稳定的</li></ul></li></ul></li></ul><h3 id="基数排序">6. 基数排序</h3><ul><li><p>算法思想</p><ul><li>将整个关键字拆分为 d 位(或“组”)</li><li>按照各个 关键字位 权重递增的次序(如:个、十、百)，做 d “分配”和“收集”若当前处理的 关键字位可能取得 r 个值，则需要建立 r 个队列</li><li>分配:顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配耗时 O(n)</li><li>收集:把各个队列中的结点依次出队并链接。一趟收集耗时 O(r)</li></ul></li><li><p>性能</p><ul><li><p>空间复杂度</p><ul><li>0(r)</li></ul></li><li><p>时间复杂度</p><ul><li>0(d(n+r))</li></ul></li><li><p>稳定性</p><ul><li>稳</li></ul></li></ul></li><li><p>擅长处理</p><ul><li>① 数据元素的关键字可以方便地拆分为 d 组，且 d 较小</li><li>② 每组关键字的取值范围不大，即 r 较小</li><li>③ 数据元素个数 n 较大</li></ul></li></ul><h3 id="各种内部排序算法的比较">7. 各种内部排序算法的比较</h3><ul><li>直接选择排序：平均时间复杂度为 O(n^2)，空间复杂度为 O(1)，不稳定。</li><li>堆排序：平均时间复杂度为 O(nlogn)，空间复杂度为 O(1)，不稳定。</li><li>直接插入排序：最好情况下的时间复杂度为 O(n)，平均时间复杂度为 O(n^2)，空间复杂度为 O(1)，稳定。</li><li>希尔排序：对于较大规模的排序可以达到较高的效率，但目前未得出其精确的渐进时间，不稳定。</li><li>冒泡排序：最好情况下的时间复杂度为 O(n)，平均时间复杂度为 O(n^2)，空间复杂度为 O(1)，稳定。</li><li>快速排序：平均性能可以达到 O(nlogn)，在实际应用中常常优于其他排序算法，不稳定。</li><li>归并排序：最好，最坏和平均时间复杂度均为 O(nlogn)，空间复杂度为 O(n)，稳定。</li><li>基数排序：适用于关键字位数较少且可以分解的情况。</li></ul><h3 id="内部排序算法的应用">8. 内部排序算法的应用</h3><ul><li>直接选择排序和直接插入排序：当元素数目较小（n≤50）时，可以采用这两种排序算法。由于直接插入排序所需的记录移动次数较简单选择排序多，因此当记录本身信息量较大时，使用简单选择排序较好。</li><li>冒泡排序和直接插入排序：如果待排序序列的初始状态已经基本有序，那么这两种排序算法是比较适合的。</li><li>快速排序，堆排序和归并排序：当待排序的序列数据规模 n 较大时，应该采用这些时间复杂度为 O(nlogn)的排序方法。</li><li>基数排序：当待排序的序列数据规模较大，且记录的关键字位数较少且可以分解时，采用基数排序比较好。</li></ul><h2 id="实现-f-向右下旋转p-向右上旋转">实现 f 向右下旋转，p 向右上旋转：</h2><p>其中 f 是爹，p 为左孩子，gf 为 f 他爹 ①f-&gt;lchild = p-&gt;rchild; ②p-&gt;rchild = f; ③gf-&gt;lchild/rchild = p;</p><h2 id="实现-f-向左下旋转p-向左上旋转">实现 f 向左下旋转，p 向左上旋转：</h2><p>①f-&gt;rchild = p-&gt;lchild;2 ②p-&gt;lchild = f; ③gf-&gt;lchild/rchild =p;</p><h1 id="完整思维导图">完整思维导图</h1><figure><img src="完整思维导图.png" srcset="/img/loading.gif" lazyload alt="完整思维导图"><figcaption aria-hidden="true">完整思维导图</figcaption></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a> <a href="/tags/%E8%80%83%E7%A0%94/" class="print-no-link">#考研</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a></div></div><div class="license-box my-3"><div class="license-title"><div>865 数据结构与程序设计</div><div>https://meteorandy.netlify.app/posts/24976/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>流星胖胖（MeteorAndy）</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年11月26日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/35673/" title="蓝桥杯刷题笔记（真题）"><span class="hidden-mobile">蓝桥杯刷题笔记（真题）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"DpHUGCpJskfsvul9py9gnP22-9Nh9j0Va",appKey:"lIWlKO4kQ2PL8vpNLiY2uFNy",path:"window.location.pathname",placeholder:"欢迎评论~~~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script></body></html>